# Module 4.6: Searching Algorithms and Complexity

Searching is the process of finding an element with specific properties within a collection of items. The efficiency of a searching algorithm is measured by its time and space complexity. The choice of algorithm often depends on whether the data is sorted or unsorted.

## 1. Linear Search (Sequential Search)

Linear Search is the most basic searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.

### How It Works
1.  Start from the first element of the array.
2.  Compare the current element with the target element (the key).
3.  If they match, return the index of the current element.
4.  If they don't match, move to the next element.
5.  If the end of the array is reached without finding a match, the search terminates, and a "not found" indicator is returned (e.g., -1).

### Algorithm (Pseudocode)
```
procedure linearSearch(list, key)
  for each index i from 0 to length(list)-1
    if list[i] == key
      return i // Element found
    end if
  end for
  return -1 // Element not found
end procedure
```

### C Code Example
```c
#include <stdio.h>

int linearSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key)
            return i; // Return the index where element is found
    }
    return -1; // Return -1 if element is not found
}

int main() {
    int arr[] = {102, 305, 210, 456, 123};
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 210;

    int result = linearSearch(arr, n, key);
    
    if (result == -1)
        printf("Element is not present in array\n");
    else
        printf("Element is present at index %d\n", result);
        
    return 0;
}
```

### Complexity Analysis
-   **Time Complexity:**
    -   **Best Case:** O(1) - The target element is the first one in the array.
    -   **Average Case:** O(n) - On average, the algorithm needs to scan half of the array.
    -   **Worst Case:** O(n) - The target element is the last one in the array, or it is not present at all.
-   **Space Complexity:** O(1) - It is an in-place algorithm that requires no extra space.

**When to Use:** Linear search is simple and effective for small or unsorted datasets. For large, unsorted datasets, it is the only option, but it can be slow.

---

## 2. Binary Search

Binary Search is a highly efficient searching algorithm that works on **sorted arrays**. It follows a Divide and Conquer approach. Instead of checking elements one by one, it repeatedly divides the search interval in half.

### Prerequisite
The input array **must be sorted** in ascending or descending order.

### How It Works (Iterative Approach)
1.  Initialize three pointers: `low` to the first index, `high` to the last index.
2.  While `low` is less than or equal to `high`:
    a. Calculate the middle index: `mid = low + (high - low) / 2`.
    b. Compare the element at `mid` with the target key.
    c. If `arr[mid] == key`, the element is found; return `mid`.
    d. If `key < arr[mid]`, the element must be in the left half. Update `high = mid - 1`.
    e. If `key > arr[mid]`, the element must be in the right half. Update `low = mid + 1`.
3.  If the loop finishes, the element is not in the array; return -1.

[**Google Image Search:** `binary search algorithm animation`](https://www.google.com/search?tbm=isch&q=binary+search+algorithm+animation)
*   **What to look for:** A visualization of a sorted array. In each step, the algorithm inspects the middle element and discards half of the remaining array, rapidly narrowing down the search space.

### C Code Example (Iterative)
```c
#include <stdio.h>

int binarySearch(int arr[], int l, int r, int key) {
    while (l <= r) {
        int mid = l + (r - l) / 2;

        // Check if key is present at mid
        if (arr[mid] == key)
            return mid;

        // If key is smaller, it can only be in the left subarray
        if (arr[mid] > key)
            r = mid - 1;
        // Else the key can only be in the right subarray
        else
            l = mid + 1;
    }
    // We reach here when element is not present
    return -1;
}

int main() {
    int arr[] = {2, 10, 24, 45, 66, 90, 170, 802};
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 90;

    int result = binarySearch(arr, 0, n - 1, key);
    
    if (result == -1)
        printf("Element is not present in array\n");
    else
        printf("Element is present at index %d\n", result);
        
    return 0;
}
```

### Complexity Analysis
-   **Time Complexity:**
    -   **Best Case:** O(1) - The target element is the middle element on the first check.
    -   **Average Case:** O(log n) - With each comparison, the search space is halved.
    -   **Worst Case:** O(log n) - The algorithm continues halving the search space until only one element is left.
-   **Space Complexity:** O(1) for the iterative version. O(log n) for the recursive version (due to the call stack).

**When to Use:** Binary search is extremely fast and is the preferred method for searching in large, **sorted** datasets.

## 3. Comparison of Searching Algorithms

| Feature | Linear Search | Binary Search |
| :--- | :--- | :--- |
| **Data Requirement** | Works on any list (sorted or unsorted). | **Must** be a sorted list. |
| **Approach** | Sequential | Divide and Conquer |
| **Worst-Case Time**| O(n) | O(log n) |
| **Space Complexity** | O(1) | O(1) (iterative) or O(log n) (recursive) |
| **Efficiency** | Slower, inefficient for large lists. | Much faster, highly efficient for large lists. |

### Importance of Sorting for Searching
Sorting a dataset can dramatically optimize searching performance.
-   If you need to perform **only one search** on a large, unsorted dataset, using Linear Search (O(n)) is faster than sorting the data (e.g., O(n log n)) and then using Binary Search (O(log n)).
-   However, if you need to perform **multiple searches** on the same dataset, the one-time cost of sorting is quickly paid off by the much faster search times of Binary Search. The total time would be O(n log n) + O(k log n), where `k` is the number of searches, which is much better than O(k * n) for `k` linear searches.

---

### Questions

<details>
  <summary><b>1. Explain the difference between linear search and binary search. When would you choose one over the other?</b></summary>
  
  **Linear Search** works by checking each element of a list sequentially from start to finish. It can be used on both sorted and unsorted lists. Its time complexity is O(n).

  **Binary Search** works on a **sorted** list by repeatedly dividing the search interval in half. It compares the target value to the middle element and discards the half where the value cannot be. Its time complexity is O(log n).

  **When to choose:**
  - **Choose Linear Search when:**
    - The dataset is small.
    - The dataset is unsorted, and you only need to perform a few searches.
  - **Choose Binary Search when:**
    - The dataset is large and sorted.
    - You will be performing many searches on the dataset. In this case, the initial cost of sorting the data is justified by the extremely fast subsequent searches.
</details>

<details>
  <summary><b>2. A hospital stores patient IDs in an unsorted list: `{102, 305, 210, 456, 123}`. A new patient arrives, and the system needs to verify if the ID already exists. Which searching technique is more appropriate and why? Show the steps to search for `210`.</b></summary>
  
  **Appropriate Technique:** **Linear Search** is the appropriate technique.

  **Why:** The problem states that the list of patient IDs is **unsorted**. Binary search has a strict prerequisite that the data must be sorted. Since the list is not sorted, linear search is the only correct option.

  **Steps to search for `210`:**
  1.  **Start at index 0:** Compare `key(210)` with `arr[0](102)`. They do not match.
  2.  **Move to index 1:** Compare `key(210)` with `arr[1](305)`. They do not match.
  3.  **Move to index 2:** Compare `key(210)` with `arr[2](210)`. They match.
  4.  **Result:** The search is successful. The element `210` is found at index `2`. The algorithm terminates.
</details>

<details>
  <summary><b>3. Implement binary search recursively using a C function.</b></summary>

  ```c
  #include <stdio.h>

  int binarySearchRecursive(int arr[], int low, int high, int key) {
      if (low <= high) {
          int mid = low + (high - low) / 2;

          // If the element is present at the middle itself
          if (arr[mid] == key)
              return mid;

          // If element is smaller than mid, then it can only be present in left subarray
          if (arr[mid] > key)
              return binarySearchRecursive(arr, low, mid - 1, key);

          // Else the element can only be present in right subarray
          return binarySearchRecursive(arr, mid + 1, high, key);
      }

      // We reach here when element is not present in array
      return -1;
  }

  int main() {
      int arr[] = {2, 10, 24, 45, 66, 90, 170, 802};
      int n = sizeof(arr) / sizeof(arr[0]);
      int key = 90;
      int result = binarySearchRecursive(arr, 0, n - 1, key);
      
      if (result == -1)
          printf("Element is not present in array\n");
      else
          printf("Element is present at index %d\n", result);
          
      return 0;
  }
  ```
  **Explanation:** The recursive function defines a base case (`low > high`) which signifies that the element is not found. In the recursive step, it calls itself on either the left or the right half of the array, effectively reducing the problem size with each call. The space complexity is O(log n) due to the recursive call stack.
</details>
