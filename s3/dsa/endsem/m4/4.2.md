# Module 4.2: Heap Sort

## 1. Introduction to Heaps

A **Heap** is a specialized tree-based data structure that is a "nearly complete binary tree" and satisfies the **heap property**.

-   **Nearly Complete Binary Tree:** A binary tree where all levels are completely filled except possibly the last level, which is filled from left to right.
-   **Heap Property:** The relationship between a parent node and its children. There are two types:
    1.  **Max-Heap:** The value of each parent node is greater than or equal to the values of its children. The largest element in the heap is always at the root.
    2.  **Min-Heap:** The value of each parent node is less than or equal to the values of its children. The smallest element in the heap is always at the root.

Heap Sort uses a Max-Heap to sort an array in ascending order.

[**Google Image Search:** `max heap vs min heap`](https://www.google.com/search?tbm=isch&q=max+heap+vs+min+heap)
*   **What to look for:** A diagram showing two binary trees with the same numbers. The Max-Heap tree will have the largest number at the root, with parent nodes always being larger than their children. The Min-Heap will show the opposite.

### Array Representation of a Heap

A heap can be efficiently represented using a simple array.
For a node at index `i`:
-   Its **Parent** is at index `floor((i-1)/2)`.
-   Its **Left Child** is at index `2*i + 1`.
-   Its **Right Child** is at index `2*i + 2`.

## 2. Heap Sort Algorithm

Heap Sort is a comparison-based sorting algorithm that leverages the properties of a Max-Heap. The algorithm works in two main phases:

1.  **Build Max-Heap (Heapify Phase):** Rearrange the input array to satisfy the Max-Heap property. This places the largest element at the root of the heap (index 0).
2.  **Sort Phase (Extraction Phase):**
    -   Swap the root element (the largest) with the last element of the heap.
    -   Reduce the size of the heap by one (effectively placing the largest element at the end of the array, in its sorted position).
    -   "Heapify" the root of the reduced heap to restore the Max-Heap property.
    -   Repeat this process until the heap size is 1.

The final array will be sorted in ascending order.

### The `heapify` Procedure

This is the core procedure for maintaining the heap property. Given a node `i`, `heapify` assumes that its left and right subtrees are already max-heaps. It "sinks down" the element at index `i` to its correct position so that the subtree rooted at `i` also becomes a max-heap.

### C Code Implementation

```c
#include <stdio.h>

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// To heapify a subtree rooted with node i which is an index in arr[].
// n is size of heap.
void heapify(int arr[], int n, int i) {
    int largest = i; // Initialize largest as root
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    // If left child is larger than root
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // If largest is not root
    if (largest != i) {
        swap(&arr[i], &arr[largest]);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

void heapSort(int arr[], int n) {
    // 1. Build a max-heap from the input data.
    // Start from the last non-leaf node and move up.
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // 2. One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {
        // Move current root to end
        swap(&arr[0], &arr[i]);

        // Call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[] = {42, 24, 32, 12, 44, 33};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Unsorted array: \n");
    printArray(arr, n);

    heapSort(arr, n);

    printf("Sorted array: \n");
    printArray(arr, n);
    return 0;
}
```

[**Google Image Search:** `heap sort algorithm animation`](https://www.google.com/search?tbm=isch&q=heap+sort+algorithm+animation)
*   **What to look for:** A two-part animation. First, it shows the array being rearranged into a max-heap tree structure. Second, it shows the root (largest element) being repeatedly swapped with the last element of the heap, and the heap being re-balanced.

### Complexity Analysis

-   **Time Complexity:**
    -   **Worst Case:** O(n log n)
    -   **Average Case:** O(n log n)
    -   **Best Case:** O(n log n)
    -   The `heapify` operation is O(log n), and the `build_heap` operation is O(n). The main loop runs `n` times, calling `heapify` each time.
-   **Space Complexity:** O(1) - It is an in-place sorting algorithm as it sorts by rearranging elements within the array itself.

### Characteristics

-   **In-place:** Yes.
-   **Stable:** No. Swapping the root with the last element can change the relative order of equal elements.
-   **Adaptive:** No. The process of building the heap and extracting elements takes the same amount of time regardless of the initial order.

---

### Questions

<details>
  <summary><b>1. Write the algorithm for Heap Sort. Sort the sequence {42, 24, 32, 12, 44, 33, 55, 65} using Heap Sort, showing the heap structure after the initial heapify phase and after each extraction.</b></summary>
  
  **Algorithm:**
  1.  Build a max-heap from the input array. This is done by starting from the last non-leaf node (`n/2 - 1`) and calling a `heapify` function for each node up to the root.
  2.  Repeat `n-1` times:
      a. Swap the root element (the maximum value) with the last element in the current heap.
      b. Reduce the heap's size by one.
      c. Call `heapify` on the root of the reduced heap to restore the max-heap property.

  **Trace for {42, 24, 32, 12, 44, 33, 55, 65}:**
  - **Initial Array:** `[42, 24, 32, 12, 44, 33, 55, 65]` (n=8)

  **Phase 1: Build Max-Heap**
  - We start heapifying from the last non-leaf node, which is at index `n/2 - 1 = 8/2 - 1 = 3`. The element is `12`.
  - After running `heapify` on indices 3, 2, 1, and 0, the array is transformed into a max-heap.
  - **Array after Heapify Phase:** `[65, 44, 55, 42, 24, 33, 32, 12]`
  - *Heap Structure:*
    ```
          65
         /  \
       44    55
      / \   /  \
     42 24 33  32
    /
   12
    ```

  **Phase 2: Sort by Extraction**
  1.  **Swap 65 and 12.** Array: `[12, 44, 55, 42, 24, 33, 32, | 65]`. Heapify root (12) on heap size 7. Array becomes `[55, 44, 33, 42, 24, 12, 32, | 65]`.
  2.  **Swap 55 and 32.** Array: `[32, 44, 33, 42, 24, 12, | 55, 65]`. Heapify root (32) on heap size 6. Array becomes `[44, 42, 33, 32, 24, 12, | 55, 65]`.
  3.  **Swap 44 and 12.** Array: `[12, 42, 33, 32, 24, | 44, 55, 65]`. Heapify root (12) on heap size 5. Array becomes `[42, 32, 33, 12, 24, | 44, 55, 65]`.
  4.  ...and so on, until the entire array is sorted.

  **Final Sorted Array:** `[12, 24, 32, 33, 42, 44, 55, 65]`
</details>

<details>
  <summary><b>2. What is the heap property? Differentiate between a Max-Heap and a Min-Heap.</b></summary>
  
  The **heap property** defines the relationship between a parent node and its children in a heap data structure. It ensures that there is a consistent order between levels of the tree.

  - **Max-Heap:** In a Max-Heap, the value of any parent node is **greater than or equal to** the values of its children. This property implies that the largest element in the heap is always located at the root node. Max-Heaps are used in Heap Sort to sort elements in ascending order.

  - **Min-Heap:** In a Min-Heap, the value of any parent node is **less than or equal to** the values of its children. This property implies that the smallest element in the heap is always located at the root node. Min-Heaps are commonly used to implement Priority Queues where the highest priority item (the smallest value) needs to be accessed quickly.
</details>

<details>
  <summary><b>3. Explain the `heapify` operation and its time complexity.</b></summary>

  The `heapify` operation (also known as `max_heapify` or `sift-down`) is a fundamental procedure for maintaining the heap property. It takes a node `i` as input and assumes that the binary trees rooted at its left and right children are already max-heaps.

  The operation works as follows:
  1.  Compare the node at `i` with its left and right children.
  2.  Find the largest among the three (node `i`, its left child, and its right child).
  3.  If the largest element is one of the children, swap it with the node at `i`.
  4.  After the swap, the original element from `i` has moved down. This might violate the max-heap property in the subtree where it landed. Therefore, the `heapify` procedure is called recursively on that subtree to continue "sinking" the element down to its correct position.
  5.  The process stops when the node `i` is larger than both its children, or when it becomes a leaf node.

  **Time Complexity:** The time complexity of `heapify` is proportional to the height of the tree, which is `log n`. Therefore, its complexity is **O(log n)**. In the worst case, an element might have to be moved from the root all the way down to a leaf level.
</details>
