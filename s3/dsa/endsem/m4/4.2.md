
# Module 4.2: Basic Sorting Algorithms

This section covers three fundamental, comparison-based sorting algorithms: Bubble Sort, Selection Sort, and Insertion Sort. While not the most efficient for large datasets, they are important for understanding the core concepts of sorting. They all have an average and worst-case time complexity of O(n²).

---

## 1. Bubble Sort

Bubble Sort is a simple algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The smaller elements "bubble" to the top (beginning) of the list.

### 1.1 How It Works
1.  Start at the beginning of the array.
2.  Compare the first and second elements. If the first is greater than the second, swap them.
3.  Move to the next pair of elements (second and third) and repeat the comparison and swap if needed.
4.  Continue this process until the end of the array. After the first pass, the largest element will have "bubbled" to the end of the array.
5.  Repeat the entire process for the remaining unsorted portion of the array (from the beginning to the second-to-last element), and so on, until the entire array is sorted.

**Optimization:** If a full pass through the array occurs with no swaps, the array is already sorted, and the algorithm can terminate early. This makes Bubble Sort adaptive.

[Click here to see a visualization of Bubble Sort](https://www.google.com/search?q=bubble+sort+algorithm+animation&tbm=isch)
> **What to look for:** An animation showing adjacent elements being compared and swapped. Notice how the largest unsorted element moves to its final position at the end of the array with each complete pass.

### 1.2 Algorithm & Complexity
*   **Time Complexity:**
    *   **Worst Case:** O(n²) - When the array is in reverse order.
    *   **Average Case:** O(n²)
    *   **Best Case:** O(n) - When the array is already sorted and the optimized version is used.
*   **Space Complexity:** O(1) - It is an in-place sort.
*   **Stability:** Stable.

---

## 2. Insertion Sort

Insertion Sort builds the final sorted array one item at a time. It iterates through the input elements and, for each element, "inserts" it into its correct position in the already-sorted part of the array.

### 2.1 How It Works
1.  Assume the first element of the array is a sorted sub-list of size 1.
2.  Take the next element (let's call it `key`) and compare it with the elements in the sorted sub-list.
3.  Shift all elements in the sorted sub-list that are greater than the `key` one position to the right.
4.  Insert the `key` into the gap that was created.
5.  Repeat this process for all remaining elements.

[Click here to see a visualization of Insertion Sort](https://www.google.com/search?q=insertion+sort+algorithm+animation&tbm=isch)
> **What to look for:** An animation showing a "sorted" portion of the array on the left and an "unsorted" portion on the right. The algorithm picks an element from the unsorted side and slides it leftwards into the correct position within the sorted part.

### 2.2 Algorithm & Complexity
*   **Time Complexity:**
    *   **Worst Case:** O(n²) - When the array is in reverse order.
    *   **Average Case:** O(n²)
    *   **Best Case:** O(n) - When the array is already sorted.
*   **Space Complexity:** O(1) - It is an in-place sort.
*   **Stability:** Stable.
*   **Adaptivity:** It is an adaptive algorithm, very efficient for nearly-sorted lists.

---

## 3. Selection Sort

Selection Sort divides the input list into two parts: a sorted sub-list which is built up from left to right, and a sub-list of the remaining unsorted items. The algorithm proceeds by finding the smallest element in the unsorted sub-list and swapping it with the leftmost unsorted element.

### 3.1 How It Works
1.  Find the minimum element in the entire array (from index 0 to n-1).
2.  Swap it with the element at the first position (index 0).
3.  Now, the first element is sorted. Move to the next sub-array (from index 1 to n-1).
4.  Find the minimum element in this new, smaller sub-array.
5.  Swap it with the element at the first position of this sub-array (index 1).
6.  Repeat this process until the entire array is sorted.

[Click here to see a visualization of Selection Sort](https://www.google.com/search?q=selection+sort+algorithm+animation&tbm=isch)
> **What to look for:** An animation where, in each pass, the algorithm scans the entire unsorted part of the array to find the minimum element, and then performs a single swap to place it at the beginning of the unsorted section.

### 3.2 Algorithm & Complexity
*   **Time Complexity:**
    *   **Worst Case:** O(n²)
    *   **Average Case:** O(n²)
    *   **Best Case:** O(n²) - The number of comparisons is always the same, regardless of the initial order.
*   **Space Complexity:** O(1) - It is an in-place sort.
*   **Stability:** Unstable.

---

## Questions

<details>
<summary>1. Write the algorithm for Insertion Sort and perform a detailed analysis of its best-case and worst-case time complexities.</summary>

**Algorithm for Insertion Sort:**
```
procedure insertionSort(A : list of sortable items)
   n = length(A)
   for i = 1 to n-1 do
       key = A[i]
       j = i - 1
       // Move elements of A[0..i-1], that are greater than key,
       // to one position ahead of their current position
       while j >= 0 and A[j] > key do
           A[j+1] = A[j]
           j = j - 1
       end while
       A[j+1] = key
   end for
end procedure
```

**Complexity Analysis:**
*   **Best Case:** O(n)
    *   **Scenario:** The input array is already sorted.
    *   **Analysis:** The outer loop runs `n-1` times. The inner `while` loop condition (`A[j] > key`) will immediately fail for every element. Therefore, only one comparison is made in the inner loop for each of the `n-1` elements. This results in a linear time complexity, O(n). This is why Insertion Sort is considered adaptive.

*   **Worst Case:** O(n²)
    *   **Scenario:** The input array is sorted in reverse order.
    *   **Analysis:** The outer loop runs `n-1` times. For each element `A[i]`, it must be compared against all `i-1` elements in the sorted sub-array to its left. This means for the 2nd element, there is 1 comparison, for the 3rd, there are 2, and for the nth, there are `n-1`. The total number of comparisons is the sum `1 + 2 + 3 + ... + (n-1)`, which is `(n-1)(n)/2`. This is O(n²).
</details>

<details>
<summary>2. Sort the array `[38, 27, 43, 3, 9]` using Selection Sort. Show the state of the array after each pass (after each swap).</summary>

**Initial Array:** `[38, 27, 43, 3, 9]`

*   **Pass 1:**
    *   Find the minimum element in `[38, 27, 43, 3, 9]`. The minimum is `3`.
    *   Swap `3` with the element at the first position (`38`).
    *   **Array after Pass 1:** `[3, 27, 43, 38, 9]`

*   **Pass 2:**
    *   Find the minimum element in the unsorted part `[27, 43, 38, 9]`. The minimum is `9`.
    *   Swap `9` with the element at the second position (`27`).
    *   **Array after Pass 2:** `[3, 9, 43, 38, 27]`

*   **Pass 3:**
    *   Find the minimum element in the unsorted part `[43, 38, 27]`. The minimum is `27`.
    *   Swap `27` with the element at the third position (`43`).
    *   **Array after Pass 3:** `[3, 9, 27, 38, 43]`

*   **Pass 4:**
    *   Find the minimum element in the unsorted part `[38, 43]`. The minimum is `38`.
    *   It is already in the correct position. No swap is needed (or swap with itself).
    *   **Array after Pass 4:** `[3, 9, 27, 38, 43]`

The array is now sorted.
</details>

<details>
<summary>3. Compare Bubble Sort and Selection Sort. Which one is generally better in practice and why? Which one performs the fewest swaps in the worst case?</summary>

**Comparison:**

| Feature         | Bubble Sort                       | Selection Sort                    |
|-----------------|-----------------------------------|-----------------------------------|
| **Time (Avg/Worst)** | O(n²)                             | O(n²)                             |
| **Time (Best)**     | O(n) (with optimization)          | O(n²)                             |
| **Swaps**         | O(n²) in worst case               | O(n) in all cases                 |
| **Stability**     | Stable                            | Unstable                          |
| **Adaptivity**    | Adaptive (with optimization)      | Non-Adaptive                      |

**Which is better?**
In most practical scenarios, neither is ideal for large datasets. However, between the two, **Selection Sort** is often slightly preferred because it performs a fixed number of swaps (`n-1`), which can be beneficial if write operations (swaps) are significantly more expensive than read operations (comparisons). Bubble Sort can perform a very large number of swaps in the worst case.

**Which performs the fewest swaps?**
**Selection Sort** performs the fewest swaps. It makes exactly `n-1` swaps in the worst case, whereas Bubble Sort can make up to `O(n²)` swaps.
</details>
