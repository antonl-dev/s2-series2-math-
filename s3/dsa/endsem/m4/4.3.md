# Module 4.3: Merge Sort

## 1. Introduction to Merge Sort

Merge Sort is a highly efficient, comparison-based sorting algorithm. It is a classic example of the **Divide and Conquer** paradigm. The algorithm is notable for its consistent O(n log n) time complexity and its stability.

The **Divide and Conquer** strategy involves three steps:
1.  **Divide:** The problem is broken down into several smaller, independent subproblems of the same type. For Merge Sort, the array is recursively divided into two halves until each subarray contains only one element.
2.  **Conquer:** The subproblems are solved recursively. If a subproblem is small enough (like an array with one element), it is solved directly. A single-element array is considered inherently sorted.
3.  **Combine:** The solutions to the subproblems are combined to create a solution for the original problem. For Merge Sort, this is the crucial **merge** step, where two sorted subarrays are combined into a single larger sorted array.

## 2. The Merge Sort Algorithm

The process consists of two main functions: a recursive function that divides the array and a helper function that merges the sorted subarrays.

### How It Works

1.  **`mergeSort(arr, left, right)` function:**
    -   If `left` is greater than or equal to `right`, the subarray has zero or one element, so it's already sorted. The function returns.
    -   Otherwise, it calculates the middle index: `mid = left + (right - left) / 2`.
    -   It recursively calls `mergeSort` on the left half: `mergeSort(arr, left, mid)`.
    -   It recursively calls `mergeSort` on the right half: `mergeSort(arr, mid + 1, right)`.
    -   Finally, it calls the `merge` function to combine the two now-sorted halves: `merge(arr, left, mid, right)`.

2.  **`merge(arr, left, mid, right)` function:**
    -   This function merges two sorted subarrays: `arr[left...mid]` and `arr[mid+1...right]`.
    -   It creates temporary arrays to hold the elements of these two subarrays.
    -   It uses three pointers: `i` for the left temp array, `j` for the right temp array, and `k` for the main array `arr`.
    -   It compares the elements at `temp_left[i]` and `temp_right[j]`. The smaller of the two is copied to `arr[k]`, and the corresponding pointer (`i` or `j`) is incremented. The pointer `k` is also incremented.
    -   This continues until one of the temporary arrays is fully copied.
    -   Finally, any remaining elements from the other temporary array are copied into `arr`.

[**Google Image Search:** `merge sort algorithm animation`](https://www.google.com/search?tbm=isch&q=merge+sort+algorithm+animation)
*   **What to look for:** A visualization that first shows the array being recursively split into single-element arrays (the "divide" phase). Then, it shows these small arrays being merged back together in sorted order, step-by-step, until the full array is sorted (the "combine" phase).

### C Code Implementation

```c
#include <stdio.h>
#include <stdlib.h>

// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
void merge(int arr[], int l, int m, int r) {
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    // Create temp arrays
    int *L = (int *)malloc(n1 * sizeof(int));
    int *R = (int *)malloc(n2 * sizeof(int));

    // Copy data to temp arrays L[] and R[]
    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    // Merge the temp arrays back into arr[l..r]
    i = 0; // Initial index of first subarray
    j = 0; // Initial index of second subarray
    k = l; // Initial index of merged subarray
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[], if any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[], if any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
    
    free(L);
    free(R);
}

// Main mergeSort function
void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        // Same as (l+r)/2, but avoids overflow for large l and h
        int m = l + (r - l) / 2;

        // Sort first and second halves
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);

        merge(arr, l, m, r);
    }
}

void printArray(int A[], int size) {
    for (int i = 0; i < size; i++)
        printf("%d ", A[i]);
    printf("\n");
}

int main() {
    int arr[] = {38, 27, 43, 3, 9, 82, 10};
    int arr_size = sizeof(arr) / sizeof(arr[0]);

    printf("Given array is \n");
    printArray(arr, arr_size);

    mergeSort(arr, 0, arr_size - 1);

    printf("\nSorted array is \n");
    printArray(arr, arr_size);
    return 0;
}
```

### Complexity Analysis

-   **Time Complexity:** **O(n log n)** for all cases (Best, Average, and Worst).
    -   The array is always divided into two halves. The recursion depth (number of levels of division) is `log n`.
    -   At each level, the `merge` function processes all `n` elements.
    -   Total work = (work per level) * (number of levels) = O(n) * log n = O(n log n).
-   **Space Complexity:** **O(n)**
    -   Merge Sort is not an in-place algorithm. The `merge` function requires temporary arrays whose total size is proportional to `n` to store the subarrays during the merge process.

### Characteristics

-   **In-place:** No.
-   **Stable:** Yes. The standard implementation of the merge step is stable. When comparing two equal elements from the subarrays, the element from the left subarray is placed first, preserving their relative order.
-   **Algorithm Paradigm:** Divide and Conquer.

---

### Questions

<details>
  <summary><b>1. Explain the "Divide and Conquer" strategy as it applies to the Merge Sort algorithm.</b></summary>
  
  The "Divide and Conquer" strategy in Merge Sort consists of three steps:
  1.  **Divide:** The primary array of `n` elements is divided into two subarrays of `n/2` elements each. This process is applied recursively to each subarray until they are broken down into single-element arrays. A single-element array is considered sorted by definition.
  2.  **Conquer:** This step is trivial. Since the base case of the recursion is a single-element array, it is already "conquered" (sorted).
  3.  **Combine:** This is the core `merge` step. Two adjacent sorted subarrays are merged to form a single, larger sorted subarray. This merging process is repeated up the recursion tree, combining `n/2` sized arrays into an `n` sized array, until the entire original array is reassembled in sorted order.
</details>

<details>
  <summary><b>2. Demonstrate Merge Sort on the array `[38, 27, 43, 3, 9, 82, 10]`. Show all the steps.</b></summary>

  **Initial Array:** `[38, 27, 43, 3, 9, 82, 10]`

  **Phase 1: Divide (Recursive Splitting)**
  - `[38, 27, 43, 3]` and `[9, 82, 10]`
  - `[38, 27]` and `[43, 3]` | `[9, 82]` and `[10]`
  - `[38]` `[27]` | `[43]` `[3]` | `[9]` `[82]` | `[10]`

  **Phase 2: Combine (Merging)**
  1.  Merge `[38]` and `[27]` -> `[27, 38]`
  2.  Merge `[43]` and `[3]` -> `[3, 43]`
  3.  Merge `[9]` and `[82]` -> `[9, 82]`
  4.  `[10]` remains as is.

  *Now merge the results from the previous step:*

  5.  Merge `[27, 38]` and `[3, 43]` -> `[3, 27, 38, 43]`
  6.  Merge `[9, 82]` and `[10]` -> `[9, 10, 82]`

  *Final merge:*

  7.  Merge `[3, 27, 38, 43]` and `[9, 10, 82]` -> `[3, 9, 10, 27, 38, 43, 82]`

  **Final Sorted Array:** `[3, 9, 10, 27, 38, 43, 82]`
</details>

<details>
  <summary><b>3. Why is Merge Sort not considered an "in-place" sorting algorithm? What is its space complexity?</b></summary>
  
  Merge Sort is not considered an "in-place" algorithm because it requires additional memory that is proportional to the number of elements being sorted. An in-place algorithm, by contrast, uses only a constant amount of extra space (O(1)).

  The extra space in Merge Sort is used during the `merge` step. To merge two sorted subarrays `A` and `B` back into the main array, their elements must be temporarily copied into separate arrays. This allows for a straightforward comparison and merging process without overwriting data that still needs to be read. The size of these temporary arrays is equal to the size of the portion of the array being merged. At each level of recursion, the total space required for these temporary arrays is proportional to `n`.

  Therefore, the **space complexity of Merge Sort is O(n)**.
</detais>
