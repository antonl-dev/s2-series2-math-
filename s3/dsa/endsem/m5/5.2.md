# Module 5.2: Hash Tables and Map Implementation

## 1. Introduction to Hash Tables

A **Hash Table** is a data structure that implements the Map ADT by storing key-value pairs in an array. It uses a special function, called a **hash function**, to compute an index into the array for each key, providing a location where the corresponding value can be stored or found.

The main advantage of a hash table is its exceptional speed. On average, insertion, deletion, and retrieval operations can be performed in **constant time, O(1)**.

### Core Components of a Hash Table

1.  **Array (The Table):** The underlying data structure is a fixed-size array, where each slot is called a **bucket** or **slot**.
2.  **Hash Function:** A function that takes a key as input and returns an integer index. This index determines the bucket where the key-value pair should be stored.
3.  **Collision Resolution Strategy:** A mechanism to handle cases where two different keys map to the same index. This is a critical part of any hash table implementation.

[**Google Image Search:** `how a hash table works`](https://www.google.com/search?tbm=isch&q=how+a+hash+table+works)
*   **What to look for:** A diagram showing a key (e.g., a name) being fed into a "Hash Function" box. An arrow points from the box to a specific index in an array, where the associated value is stored.

## 2. The Hashing Mechanism

The process of mapping a key to an index and storing the value is called **hashing**.

1.  **Input:** A key-value pair, for example `("John Smith", "555-1234")`, needs to be stored.
2.  **Hashing the Key:** The key `"John Smith"` is passed to the hash function.
3.  **Computing the Index:** The hash function processes the key and returns a numerical index, for example, `152`. This is often done by first computing a large integer hash code and then taking the modulus with the array size (e.g., `hash_code % array_size`).
4.  **Storing the Data:** The value `"555-1234"` is stored at index `152` in the array.

To retrieve the data later, the exact same process is followed. Hashing the key `"John Smith"` will again produce the index `152`, allowing for direct access to the stored value.

## 3. The Problem: Hash Collisions

A **hash collision** occurs when the hash function generates the same index for two or more different keys.

**Example:**
-   `hash("John Smith")` -> `152`
-   `hash("Sandra Dee")` -> `152`

If we try to store both "John Smith" and "Sandra Dee" in our hash table, they will both map to the same bucket (index 152). We cannot simply overwrite the existing data, as that would result in data loss.

**Why Collisions Happen:**
-   A hash function maps a potentially infinite set of keys to a finite number of array indices.
-   By the **pigeonhole principle**, if there are more keys than available indices, collisions are inevitable.

Handling these collisions effectively is the most important challenge in designing a hash table. The methods for doing this are called **collision resolution schemes**, which will be covered in detail in section 5.4.

## 4. Properties of a Good Hash Function

The quality of the hash function is the most critical factor in a hash table's performance. A good hash function should have the following properties:

1.  **Deterministic:** The same key must always produce the same hash index. `hash(key)` should be a pure function.
2.  **Efficient to Compute:** The function must be fast, ideally running in O(1) time relative to the key size. A slow hash function would defeat the purpose of using a hash table.
3.  **Uniform Distribution:** The function should distribute keys as evenly as possible across all the available buckets. This minimizes the number of collisions and prevents "clustering," where many keys map to a small number of buckets.

## 5. Implementing Map Operations with a Hash Table

Here is how the core Map ADT operations are implemented using a hash table:

-   `put(key, value)`:
    1.  Calculate the hash index for the `key`.
    2.  Go to that index in the array.
    3.  If the bucket is empty, store the `(key, value)` pair there.
    4.  If the bucket is already occupied (a collision), apply the chosen collision resolution strategy to find a new place to store the pair.

-   `get(key)`:
    1.  Calculate the hash index for the `key`.
    2.  Go to that index in the array.
    3.  If the bucket contains the correct key, return its associated value.
    4.  If the bucket contains a different key (due to a collision), apply the collision resolution strategy to search for the correct key in other potential locations.
    5.  If an empty bucket is found during the search, the key does not exist in the table.

-   `remove(key)`:
    1.  Follow the same search process as `get(key)`.
    2.  Once the `(key, value)` pair is located, remove it. Special care must be taken in some collision resolution schemes (like open addressing) to ensure that this removal doesn't break the search chain for other elements.

---

### Questions

<details>
  <summary><b>1. What is a hash table and what are its three main components?</b></summary>
  
  A **hash table** is a data structure used to implement a Map ADT. It maps keys to values for highly efficient lookups. Its main components are:
  1.  **Array (The Table):** An array where the data (values or key-value pairs) is stored. Each slot in the array is a "bucket".
  2.  **Hash Function:** A function that takes a key as input and computes an integer index, determining which bucket the key belongs to.
  3.  **Collision Resolution Strategy:** A set of rules for handling the situation when two different keys hash to the same index.
</details>

<details>
  <summary><b>2. What is a hash collision? Why are collisions inevitable in a hash table?</b></summary>
  
  A **hash collision** is an event that occurs when a hash function produces the same array index for two or more different input keys.

  Collisions are inevitable due to the **pigeonhole principle**. A hash table has a finite number of buckets (pigeonholes), but the set of possible keys (pigeons) is often much larger or even infinite. When the number of keys to be stored exceeds the number of available buckets, at least one bucket must contain more than one key, resulting in a collision. Even with fewer keys than buckets, a non-perfect hash function can still produce collisions.
</details>

<details>
  <summary><b>3. What are the three essential properties of a good hash function? Explain why each is important.</b></summary>
  
  1.  **Deterministic:** The function must always return the same index for the same key. This is important because if it didn't, we would have no reliable way to find an element after storing it.
  2.  **Efficient to Compute:** The function must be fast. The primary benefit of a hash table is its O(1) average performance. If the hash function itself were slow (e.g., O(n)), it would become the bottleneck and nullify the advantage of the data structure.
  3.  **Uniform Distribution:** The function should spread keys evenly across all buckets. This is crucial for minimizing the frequency of hash collisions. Poor distribution leads to clustering, where many keys map to a few buckets, degrading the hash table's performance to that of a linked list (O(n)).
</details>
