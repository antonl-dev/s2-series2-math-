
# Module 5.1: The Map Abstract Data Type (ADT)

## 1. Introduction to the Map ADT

A **Map** (also known as a Dictionary, Associative Array, or Key-Value Store) is an Abstract Data Type that stores a collection of `(key, value)` pairs, such that each possible key appears at most once in the collection.

The primary purpose of a Map is to provide efficient lookup, insertion, and deletion of values based on their associated keys. It is one of the most fundamental data structures in computer science, used for tasks like database indexing, caching, and symbol tables in compilers.

### Key Characteristics of a Map

-   **Key-Value Association:** Data is stored and retrieved in pairs. The `key` is used as a unique identifier to access its corresponding `value`.
-   **Uniqueness of Keys:** No two entries in a map can have the same key. If you try to insert a new value with an existing key, the map will typically update the old value with the new one.
-   **Unordered (Typically):** In its most common form, a Map does not guarantee any specific order for its key-value pairs.

[**Google Image Search:** `map adt key value pairs`](https://www.google.com/search?tbm=isch&q=map+adt+key+value+pairs)
*   **What to look for:** A diagram showing a set of unique keys (like names or IDs) pointing to corresponding values. This visually represents the core concept of association.

## 2. Core Operations of a Map ADT

A standard Map ADT supports the following primary operations:

-   `put(key, value)`: Associates the specified `value` with the specified `key`.
    -   If the map already contains the key, the old value is replaced.
    -   If the key is new, a new `(key, value)` pair is created.

-   `get(key)`: Retrieves the `value` to which the specified `key` is mapped.
    -   Returns the value if the key exists.
    -   Returns a special indicator (like `null` or `None`) if the key is not found.

-   `remove(key)`: Removes the mapping for a key from the map if it is present.
    -   Returns the value that was associated with the key, or `null` if there was no mapping.

-   `containsKey(key)`: Checks if the map contains a mapping for the specified `key`.
    -   Returns `true` if the key exists, `false` otherwise.

-   `size()`: Returns the number of key-value mappings in the map.

-   `isEmpty()`: Returns `true` if the map contains no key-value mappings, `false` otherwise.

## 3. Implementing the Map ADT

The Map ADT is a conceptual model; it can be implemented using various underlying data structures. The choice of implementation affects the performance of the core operations.

#### a. Using an Unsorted List/Array
-   **Implementation:** Store `(key, value)` pairs in a list.
-   **`put(key, value)`:** O(n) - Must scan the list to check if the key already exists before adding.
-   **`get(key)`:** O(n) - Requires a linear search to find the key.
-   **`remove(key)`:** O(n) - Requires a linear search to find the key before removing it.
-   **Conclusion:** Very inefficient for large datasets.

#### b. Using a Sorted List/Array (Based on Keys)
-   **Implementation:** Keep the `(key, value)` pairs sorted by key.
-   **`get(key)`:** O(log n) - Can use binary search to find the key quickly.
-   **`put(key, value)`:** O(n) - Finding the position is O(log n), but inserting the element requires shifting other elements, which takes O(n) time.
-   **`remove(key)`:** O(n) - Finding is O(log n), but removal requires shifting elements.
-   **Conclusion:** Fast lookups, but slow insertions and deletions.

#### c. Using a Balanced Binary Search Tree (like AVL or Red-Black Tree)
-   **Implementation:** The nodes of the tree store the `(key, value)` pairs, ordered by the key.
-   **`put`, `get`, `remove`:** O(log n) - All operations are logarithmic because the tree remains balanced.
-   **Conclusion:** Provides a good, guaranteed performance for all major operations. It also has the added benefit of being able to iterate through keys in sorted order.

#### d. Using a Hash Table (Most Common Implementation)

-   **Implementation:** A **Hash Table** is an array-based data structure that uses a **hash function** to compute an index (or "hash code") from a key. This index is where the corresponding value is stored.
-   **`put`, `get`, `remove`:** **O(1)** on average. This is the main advantage of using a hash table.
    -   In the worst case (due to hash collisions), performance can degrade to O(n). However, with a good hash function and collision resolution strategy, this is rare.
-   **Conclusion:** The most efficient implementation for general-purpose maps, offering average constant-time performance for the most critical operations.

Because of its superior average-case performance, the **Hash Table** is the de-facto standard implementation for the Map ADT in most programming languages and applications. The subsequent sections will focus on how hash tables work in detail.

---

### Questions

<details>
  <summary><b>1. What is a Map ADT? Describe its fundamental purpose and list its core operations.</b></summary>
  
  A **Map** is an Abstract Data Type that stores a collection of unique keys and their associated values as `(key, value)` pairs. Its fundamental purpose is to provide a mechanism for storing, retrieving, and deleting data efficiently based on a key.

  **Core Operations:**
  -   `put(key, value)`: Inserts or updates a key-value pair.
  -   `get(key)`: Retrieves the value associated with a given key.
  -   `remove(key)`: Deletes the key-value pair for a given key.
  -   `containsKey(key)`: Checks for the existence of a key.
  -   `size()`: Returns the number of pairs in the map.
</details>

<details>
  <summary><b>2. Compare and contrast implementing a Map ADT using a balanced Binary Search Tree versus a Hash Table.</b></summary>
  
  | Feature | Balanced Binary Search Tree (BST) | Hash Table |
  | :--- | :--- | :--- |
  | **Time Complexity** | **Guaranteed O(log n)** for `put`, `get`, and `remove`. | **Average O(1)** for `put`, `get`, and `remove`. Worst case is O(n). |
  | **Ordering** | Keys are stored in sorted order, allowing for efficient range queries and ordered traversal. | Keys are generally unordered. |
  | **Space Complexity**| Typically requires more space per entry due to pointers for left/right children and balancing information. | Can be more space-efficient, but may have unused slots in the underlying array. |
  | **Use Case** | Ideal when ordered data is a requirement, or when a guaranteed worst-case performance is critical. | Ideal for general-purpose, high-speed lookups where order does not matter and average-case performance is the priority. |

  **Summary:** Hash Tables offer better average performance (O(1)) and are generally faster, making them the default choice. Balanced BSTs are chosen when guaranteed logarithmic performance is needed or when operations related to the order of keys (like finding the next-largest key) are required.
</details>

<details>
  <summary><b>3. Why is "uniqueness of keys" a critical property of a Map ADT?</b></summary>
  
  The uniqueness of keys is critical because the key serves as the sole identifier for retrieving a specific value. If a map were to allow duplicate keys, it would create ambiguity. For example, if you called `get("user_id_123")`, and there were multiple entries with that key, the map wouldn't know which value to return.

  This property ensures that every `get`, `put` (for an update), and `remove` operation is deterministic and predictable. It guarantees that for any given key, there is at most one associated value, which is the fundamental contract of the Map ADT.
</details>
