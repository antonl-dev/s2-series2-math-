# Module 2: Arrays and Linked List

## 2.1.a Stacks (Array Implementation)

A **Stack** is a fundamental linear data structure that follows the **LIFO (Last-In, First-Out)** principle. This means the last element added to the stack will be the first one to be removed.

A common analogy is a pile of plates: you can only add a new plate to the top, and you can only remove the topmost plate. All operations—insertion and deletion—happen at a single end known as the **`top`** of the stack.

[Click here for a diagram of a Stack (LIFO)](https://www.google.com/search?tbm=isch&q=stack+data+structure+LIFO+push+pop)
**What to look for:** A visual showing elements being added (pushed) onto the top of a vertical structure and being removed (popped) from the same top position.

### Key Stack Operations (ADT)

*   **`push(item)`:** Inserts an element onto the top of the stack. If the stack is already full, this results in an **Overflow** condition.
*   **`pop()`:** Deletes and returns the element from the top of the stack. If the stack is empty, this results in an **Underflow** condition.
*   **`peek()` (or `top()`):** Returns the topmost element of the stack without deleting it.
*   **`isEmpty()`:** Checks if the stack is empty.
*   **`isFull()`:** Checks if the stack is full (relevant for array implementations).

### Array Implementation of a Stack

A stack is commonly implemented using a simple one-dimensional array.

*   **Structure:** We use an array (e.g., `stack[MAX_SIZE]`) to store the elements.
*   **Top Pointer:** An integer variable, `top`, is used as an index to keep track of the topmost element.
*   **Initialization:** The `top` index is initialized to `-1`. This is a conventional way to indicate that the stack is completely empty.

### Algorithm for `push(value)` (Insertion)

This algorithm adds an element to the top of the stack.

**Pseudocode:**
```
Step 1: IF TOP == MAX_SIZE - 1, then
           PRINT "OVERFLOW"
           Exit
        [END OF IF]
Step 2: SET TOP = TOP + 1
Step 3: SET STACK[TOP] = value
```

**Detailed Line-by-Line Explanation:**

*   **`Step 1: IF TOP == MAX_SIZE - 1`**
    *   **Purpose:** This is the **overflow check**.
    *   **Why?** Arrays have a fixed size (`MAX_SIZE`). Since array indices are 0-based, the last valid index is `MAX_SIZE - 1`. If `top` is already at this last position, it means the array is full and no more elements can be added.

*   **`Step 2: SET TOP = TOP + 1`**
    *   **Purpose:** To make space for the new element.
    *   **Why?** Before we can place the new value, we must first increment the `top` index to point to the next available empty slot in the array. If the stack was empty (`top = -1`), this step correctly moves `top` to `0`, the first position.

*   **`Step 3: SET STACK[TOP] = value`**
    *   **Purpose:** To insert the new value.
    *   **Why?** After the `top` index has been updated to point to an empty slot, this statement places the new `value` into the array at that position, making it the new top element of the stack.

### Algorithm for `pop()` (Deletion)

This algorithm removes and returns the element from the top of the stack.

**Pseudocode:**
```
Step 1: IF TOP == -1, then
           PRINT "UNDERFLOW"
           Exit
        [END OF IF]
Step 2: SET value = STACK[TOP]
Step 3: SET TOP = TOP - 1
Step 4: RETURN value
```

**Detailed Line-by-Line Explanation:**

*   **`Step 1: IF TOP == -1`**
    *   **Purpose:** This is the **underflow check**.
    *   **Why?** `top = -1` is our defined state for an empty stack. If the stack is empty, there is no element to remove. Attempting to do so would be an error.

*   **`Step 2: SET value = STACK[TOP]`**
    *   **Purpose:** To save the value of the top element before it is removed.
    *   **Why?** The `pop` operation is expected to return the removed value. We must first retrieve the data from `STACK[TOP]` and store it in a temporary variable before we modify the `top` index.

*   **`Step 3: SET TOP = TOP - 1`**
    *   **Purpose:** This is the actual "removal" step.
    *   **Why?** We don't need to physically erase the data from the array. By simply decrementing the `top` index, we are logically removing the element. The old value at that position is now considered inaccessible and will be overwritten by the next `push` operation that reaches that index.

*   **`Step 4: RETURN value`**
    *   **Purpose:** To return the removed element to the caller.
    *   **Why?** This completes the `pop` operation by providing the value that was just removed from the top of the stack.

---

### Questions

1.  Define a stack and explain its basic operations with examples of push, pop, and peek. (From *Internal Test - 1*)
2.  What are the "overflow" and "underflow" conditions in a stack?
3.  Explain the process of implementing a stack using an array. What is the role of the 'top' variable and why is it initialized to -1?
4.  Describe two applications where a stack data structure is used.

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

A **Stack** is a linear data structure that operates on the **LIFO (Last-In, First-Out)** principle. This means that the last element to be inserted is the first one to be removed. All operations occur at a single end called the **`top`**.

**Basic Operations:**

*   **`push(item)`:** This operation adds a new item to the top of the stack. The `top` index is incremented, and the new item is placed at that new `top` position.
    *   *Example:* If a stack contains `[10, 20]` with `top` at index 1 (pointing to 20), a `push(30)` operation would result in the stack being `[10, 20, 30]` with `top` now at index 2.

*   **`pop()`:** This operation removes the topmost item from the stack. The item at the `top` index is returned, and then the `top` index is decremented.
    *   *Example:* If a stack contains `[10, 20, 30]` with `top` at index 2, a `pop()` operation would return `30`, and the stack would become `[10, 20]` with `top` now at index 1.

*   **`peek()`:** This operation returns the value of the topmost item without removing it from the stack. The `top` index is not changed.
    *   *Example:* If a stack contains `[10, 20, 30]`, a `peek()` operation would return `30`, but the stack remains `[10, 20, 30]`.

---

#### Answer to Question 2

*   **Overflow:** This condition occurs when one tries to perform a `push` operation on a stack that is already full. In an array implementation of size `N`, this happens when the `top` index is equal to `N-1`. At this point, no more elements can be added.

*   **Underflow:** This condition occurs when one tries to perform a `pop` or `peek` operation on a stack that is empty. In an array implementation where an empty stack is represented by `top = -1`, an underflow occurs if `pop` is called when `top` is already `-1`.

---

#### Answer to Question 3

Implementing a stack using an array involves two main components:
1.  **An Array:** A fixed-size block of memory to store the stack elements.
2.  **A `top` variable:** An integer that acts as an index to the array.

**Role of the `top` variable:**
The `top` variable is crucial as it You are absolutely right. My apologies. I misinterpreted your instruction and jumped ahead. Thank you for the correction and for the clear feedback.

I will follow your new instructions precisely:
1.  **Split the topics**: Stacks and Queues will be in separate files (`2.1.a.md` and `2.1.b.md`).
2.  **Provide detailed explanations for algorithms**: Every line of pseudocode will be explained to clarify its purpose and logic.

Let's start over with Module 2. Here is the revised and improved version for **Stacks**, now correctly numbered as `2.1.a.md`.

***

```markdownalways points to the index of the **last element inserted** into the stack. It manages where the next `push` operation will place an element and from where a `pop` operation will remove an element.

**Why initialize `top` to -1?**
Initializing `top` to `-1` is a standard convention to signify that the stack is **empty**. This has a practical advantage: when the first element is pushed, the `push` algorithm first increments `top` (from -1 to 0) and then places the element at `stack[top]`. This allows the first element to be correctly placed at index `0` of the array without needing a separate special case for the first insertion.

---

#### Answer to Question 4

Stacks are used in a wide variety of computing applications:

1.  **Function Call Management:** When you call a function, the system pushes its information (local variables, return address) onto the **call stack**. When a function returns, its information is popped off the stack. This LIFO behavior is perfect for managing nested function calls, as the last function called must be the first to finish.

2.  **Expression Evaluation and Conversion:** Stacks are fundamental for parsing and evaluating mathematical expressions. For example, to convert an **infix expression** (like `3 + 4 * 5`) to a **postfix expression** (`3 4 5 * +`), an operator stack is used to handle precedence rules. Similarly, a stack is used to evaluate the final postfix expression.

</details>
