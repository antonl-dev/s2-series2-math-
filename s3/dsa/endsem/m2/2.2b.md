# Module 2: Arrays and Linked List

## 2.2.b Double-Ended Queues (Deque)

### 1. What is a Deque?

A **Double-Ended Queue**, or **Deque** (pronounced "deck"), is a generalized version of a queue. Unlike a standard queue where insertions happen at one end (rear) and deletions at the other (front), a deque allows **insertion and deletion at both ends**.

This hybrid nature means it can behave like a queue (by using `insertRear` and `deleteFront`) or like a stack (by using `insertFront` and `deleteFront`, or `insertRear` and `deleteRear`).

[Click here for a diagram of a Deque](https://www.google.com/search?tbm=isch&q=deque+data+structure+operations)
**What to look for:** A diagram of a linear structure (like a queue) but with arrows indicating that elements can be added or removed from both the left (front) and right (rear) ends.

### 2. Types of Deques

Deques can be further classified based on restrictions to their operations:

*   **Input-Restricted Deque:** Insertions are allowed at only one end, but deletions are allowed at both ends.
*   **Output-Restricted Deque:** Deletions are allowed at only one end, but insertions are allowed at both ends.

### 3. Key Deque Operations (ADT)

The four fundamental operations for a deque are:
*   `insertFront(value)`: Adds an element at the front.
*   `insertRear(value)`: Adds an element at the rear.
*   `deleteFront()`: Removes an element from the front.
*   `deleteRear()`: Removes an element from the rear.

### 4. Array Implementation of a Deque

To handle insertions and deletions at both ends efficiently, an array-based deque must be implemented as a **circular array**, just like a circular queue. This prevents the "drifting" issue and allows the deque to wrap around the array's boundaries.

### 5. Algorithms with Detailed Explanations

The following algorithms are based on the logic from your handwritten notes.

#### a) Algorithm for `insertFront(value)`

**Pseudocode:**
```
Step 1: IF (front == 0 AND rear == MAX-1) OR (front == rear + 1)
           PRINT "OVERFLOW"
           Exit
        [END OF IF]
Step 2: IF front == -1
           SET front = 0, rear = 0
        ELSE IF front == 0
           SET front = MAX-1
        ELSE
           SET front = front - 1
        [END OF IF]
Step 3: SET DEQUE[front] = value
```
**Detailed Explanation:**
*   **`Step 1: Check for Overflow`**:
    *   **Purpose:** To check if the deque is full.
    *   **Why?** There are two ways a circular array can be full:
        1.  `front == 0 AND rear == MAX-1`: The deque occupies the entire array without wrapping.
        2.  `front == rear + 1`: The `front` is just ahead of the `rear` after `rear` has wrapped around. This indicates all slots are filled.
*   **`Step 2: Handle pointer adjustment`**:
    *   **`IF front == -1`**: This handles the insertion of the **first element**. It initializes both `front` and `rear` to `0`.
    *   **`ELSE IF front == 0`**: This handles the **wrap-around case**. If we need to insert at the front but `front` is already at index `0`, we must wrap it around to the end of the array (`MAX-1`).
    *   **`ELSE`**: This is the **standard case**. We simply decrement `front` to point to the previous index to make space.
*   **`Step 3: SET DEQUE[front] = value`**:
    *   **Purpose:** To insert the new data.
    *   **Why?** After the `front` pointer is correctly positioned (either at 0, decremented, or wrapped around), the value is placed at that location.

#### b) Algorithm for `insertRear(value)`

**Pseudocode:**
```
Step 1: IF (front == 0 AND rear == MAX-1) OR (front == rear + 1)
           PRINT "OVERFLOW"
           Exit
        [END OF IF]
Step 2: IF front == -1
           SET front = 0, rear = 0
        ELSE IF rear == MAX-1
           SET rear = 0
        ELSE
           SET rear = rear + 1
        [END OF IF]
Step 3: SET DEQUE[rear] = value
```
**Detailed Explanation:** This is very similar to `insertFront`, but for the `rear` pointer.
*   **`Step 1: Check for Overflow`**: Same logic as `insertFront`.
*   **`Step 2: Handle pointer adjustment`**:
    *   **`IF front == -1`**: Initializes an empty deque by setting both pointers to `0`.
    *   **`ELSE IF rear == MAX-1`**: Handles the **wrap-around case**. If `rear` is at the end, it wraps around to `0`.
    *   **`ELSE`**: The **standard case**. Increment `rear` to point to the next slot.
*   **`Step 3: SET DEQUE[rear] = value`**: Inserts the data at the new `rear` position.

#### c) Algorithm for `deleteFront()`

**Pseudocode:**
```
Step 1: IF front == -1
           PRINT "UNDERFLOW"
           Exit
        [END OF IF]
Step 2: SET value = DEQUE[front]
Step 3: IF front == rear
           SET front = -1, rear = -1
        ELSE IF front == MAX-1
           SET front = 0
        ELSE
           SET front = front + 1
        [END OF IF]
Step 4: RETURN value
```
**Detailed Explanation:**
*   **`Step 1: Check for Underflow`**: If `front` is `-1`, the deque is empty.
*   **`Step 2: SET value = DEQUE[front]`**: Retrieves the value before it's "deleted".
*   **`Step 3: Handle pointer adjustment`**:
    *   **`IF front == rear`**: This handles deleting the **last element**. The deque becomes empty, so both pointers are reset to `-1`.
    *   **`ELSE IF front == MAX-1`**: This handles the **wrap-around case**. If `front` is at the end of the array, it wraps around to `0`.
    *   **`ELSE`**: The **standard case**. The `front` pointer is simply incremented.
*   **`Step 4: RETURN value`**: Returns the deleted element.

#### d) Algorithm for `deleteRear()`

**Pseudocode:**
```
Step 1: IF front == -1
           PRINT "UNDERFLOW"
           Exit
        [END OF IF]
Step 2: SET value = DEQUE[rear]
Step 3: IF front == rear
           SET front = -1, rear = -1
        ELSE IF rear == 0
           SET rear = MAX-1
        ELSE
           SET rear = rear - 1
        [END OF IF]
Step 4: RETURN value
```
**Detailed Explanation:**
*   **`Step 1: Check for Underflow`**: Checks if the deque is empty.
*   **`Step 2: SET value = DEQUE[rear]`**: Retrieves the value from the rear.
*   **`Step 3: Handle pointer adjustment`**:
    *   **`IF front == rear`**: Resets pointers to `-1` if the last element is being deleted.
    *   **`ELSE IF rear == 0`**: Handles the **wrap-around case**. If deleting from the rear and `rear` is at `0`, it must wrap around to `MAX-1`.
    *   **`ELSE`**: The **standard case**. Decrement `rear` to "remove" the last element.
*   **`Step 4: RETURN value`**: Returns the deleted element.

---

### Questions

1.  Define a deque and list its four main operations.
2.  How does a deque differ from a standard queue and a stack?
3.  Explain the overflow condition in an array-based deque. Why are there two parts to the check (`(front == 0 && rear == MAX-1) || (front == rear + 1)`)?
4.  Write the algorithm for `deleteRear()` and explain the logic for the "wrap-around" case.

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

A **Double-Ended Queue (Deque)** is a linear data structure that allows insertion and deletion of elements from both endsâ€”the front and the rear.

Its four main operations are:
1.  **`insertFront(value)`:** Adds an element to the front of the deque.
2.  **`insertRear(value)`:** Adds an element to the rear of the deque.
3.  **`deleteFront()`:** Removes an element from the front of the deque.
4.  **`deleteRear()`:** Removes an element from the rear of the deque.

---

#### Answer to Question 2

*   **Difference from a Queue:** A standard queue is a strict FIFO structure where insertions are only allowed at the `rear` and deletions are only allowed at the `front`. A deque is more flexible, allowing both operations at both ends.

*   **Difference from a Stack:** A stack is a strict LIFO structure where both insertions (`push`) and deletions (`pop`) are only allowed at one end, the `top`. A deque can simulate a stack by using only one end (e.g., using `insertFront` and `deleteFront`).

In essence, a deque is a more general and powerful data structure that can behave like both a stack and a queue.

---

#### Answer to Question 3

The overflow condition in an array-based deque checks if the circular array is completely full. This check has two parts because the deque can be full in two different configurations:

1.  **`(front == 0 && rear == MAX-1)`:** This part checks for the "non-wrapped" full state. It occurs when `front` is at the very beginning of the array (index 0) and `rear` is at the very end (index `MAX-1`). This means every slot from 0 to `MAX-1` is occupied.

2.  **`(front == rear + 1)`:** This part checks for the "wrapped-around" full state. It occurs after the `rear` pointer has wrapped around the end of the array and is now positioned just behind the `front` pointer. This also signifies that all available slots are filled, with the occupied cells forming a "loop" within the array.

If either of these conditions is true, the deque is full.

---

#### Answer to Question 4

**Algorithm for `deleteRear()`:**
```
Step 1: IF front == -1, PRINT "UNDERFLOW" and exit.
Step 2: SET value = DEQUE[rear].
Step 3: IF front == rear, SET front = -1, rear = -1.
        ELSE IF rear == 0, SET rear = MAX-1.
        ELSE SET rear = rear - 1.
Step 4: RETURN value.
```
**Logic for the "wrap-around" case (`ELSE IF rear == 0`):**
The `deleteRear` operation works by moving the `rear` pointer backward (decrementing it). The wrap-around case handles the situation where the `rear` pointer is currently at the beginning of the array (index `0`). If we were to simply decrement it, it would go to `-1`, which is the indicator for an empty queue and would be incorrect. Instead, to maintain the circular nature of the array, we must "wrap" the pointer around to the end of the array. Therefore, if `rear` is `0`, we set it to `MAX-1`, which is the last valid index. This correctly positions the `rear` pointer at the new logical end of the deque.

</details>
