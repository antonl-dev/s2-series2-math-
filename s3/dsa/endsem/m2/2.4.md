# Module 2: Arrays and Linked List

## 2.3 Evaluation of Expressions

One of the most important applications of the stack data structure is parsing and evaluating mathematical expressions. As your teacher emphasized, questions on converting and evaluating expressions are very common in exams. Stacks are perfectly suited for this task because they can reverse the order of items and manage the precedence of operators, which is essential for these algorithms.

### 1. Expression Notations

A mathematical expression consists of operands (values like `5`, `A`) and operators (`+`, `*`). There are three common ways to write these expressions:

1.  **Infix Notation:** This is the standard way humans write expressions. The operator is placed **between** the operands.
    *   Example: `A + B`

2.  **Prefix Notation (Polish Notation):** The operator is placed **before** its operands.
    *   Example: `+ A B`

3.  **Postfix Notation (Reverse Polish Notation - RPN):** The operator is placed **after** its operands. This notation is ideal for computer evaluation because it doesn't require parentheses or precedence rules to be stored.
    *   Example: `A B +`

### 2. Operator Precedence and Associativity

To correctly convert from infix to postfix, we must respect the order of operations. This is determined by two rules:

*   **Precedence:** Which operators are performed first. For example, multiplication (`*`) has a higher precedence than addition (`+`).
*   **Associativity:** In which direction operators with the same precedence are evaluated (left-to-right or right-to-left). Most operators are left-associative. Exponentiation (`^`) is a common exception, being right-associative.

[Click here for a diagram of an Operator Precedence Table](https://www.google.com/search?tbm=isch&q=operator+precedence+table+data+structures)
**What to look for:** A table listing operators like `^`, `*`, `/`, `+`, `-` and ranking them by priority.

| Operator                  | Precedence | Associativity |
| :------------------------ | :--------: | :-----------: |
| `^` (Exponentiation)      |     3      | Right-to-Left |
| `*` (Multiplication), `/` (Division) |     2      |  Left-to-Right  |
| `+` (Addition), `-` (Subtraction) |     1      |  Left-to-Right  |

### 3. Algorithm: Infix to Postfix Conversion

This algorithm uses a stack to temporarily hold operators that cannot be placed into the postfix expression yet due to precedence rules.

**Pseudocode:**
1.  Read the infix expression from left to right, one symbol at a time.
2.  If the symbol is an **operand**, append it directly to the output postfix string.
3.  If the symbol is an **operator**:
    *   While the stack is not empty, and the top of the stack is not `(`, and the operator at the top of the stack has higher or equal precedence than the incoming symbol, **pop** the operator from the stack and append it to the postfix string.
    *   After the loop, **push** the incoming operator onto the stack.
4.  If the symbol is an **opening parenthesis `(`**, push it onto the stack.
5.  If the symbol is a **closing parenthesis `)`**:
    *   Pop all operators from the stack and append them to the postfix string until an opening parenthesis `(` is encountered.
    *   Pop and discard the opening parenthesis `(`.
6.  After scanning the entire infix expression, pop any remaining operators from the stack and append them to the postfix string.

[Click here for an animation of Infix to Postfix Conversion](https://www.google.com/search?tbm=isch&q=infix+to+postfix+stack+visualization+gif)
**What to look for:** An animation showing an infix expression being read. Watch how operands go straight to the output, while operators are pushed onto a stack and popped off based on precedence rules.

### 4. C Implementation and Explanation for Infix to Postfix

This C code is a direct implementation of the algorithm described above.

**Source Code (from provided notes):**
```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

// Function to return precedence of operators
int prec(char c) {
    if (c == '^')
        return 3;
    else if (c == '/' || c == '*')
        return 2;
    else if (c == '+' || c == '-')
        return 1;
    else
        return -1; // For '('
}

// Function to convert Infix expression to Postfix
void infixToPostfix(char* exp) {
    int len = strlen(exp);
    char result[len + 1]; // output string
    char stack[len];      // operator stack
    int j = 0;            // index for result
    int top = -1;         // top of stack

    for (int i = 0; i < len; i++) {
        char c = exp[i];

        // If operand, add to result
        if (isalnum(c)) {
            result[j++] = c;
        }
        // If '(', push to stack
        else if (c == '(') {
            stack[++top] = c;
        }
        // If ')', pop until '('
        else if (c == ')') {
            while (top != -1 && stack[top] != '(') {
                result[j++] = stack[top--];
            }
            top--; // remove '(' from stack
        }
        // If operator
        else {
            while (top != -1 && prec(c) <= prec(stack[top])) {
                result[j++] = stack[top--];
            }
            stack[++top] = c;
        }
    }

    // Pop remaining operators
    while (top != -1) {
        result[j++] = stack[top--];
    }
    result[j] = '\0'; // null terminate
    printf("Postfix Expression: %s\n", result);
}
```

**Detailed Code Explanation:**
*   `int prec(char c)`: A helper function that returns the precedence level of an operator. Higher numbers mean higher precedence. It returns -1 for `(`, which ensures it never gets popped by a regular operator.
*   `char result[]`, `char stack[]`: We declare a result array to build the postfix string and a character array to act as our operator stack.
*   `for (int i = 0; i < len; i++)`: The main loop iterates through the input infix expression `exp` character by character.
*   `if (isalnum(c))`: `isalnum()` checks if the character `c` is a letter or a number. If it is, it's an operand, so we add it directly to our `result` string.
*   `else if (c == '(')`: An opening parenthesis is always pushed onto the stack. It acts as a marker for a sub-expression.
*   `else if (c == ')')`: When a closing parenthesis is found, we need to resolve the sub-expression. The `while` loop pops every operator from the stack and adds it to the `result` until it finds the matching opening `(`. The `top--` at the end discards the `(`.
*   `else { ... }`: This block handles operators. The `while` loop checks the precedence. It pops operators from the stack as long as the operator on the stack has precedence greater than or equal to the current operator `c`. This correctly handles rules like "in `a+b*c`, `+` must wait for `*`".
*   `while (top != -1)`: After the main loop finishes, this final loop empties the stack of any remaining operators and appends them to the result.

### 5. Algorithm: Evaluation of a Postfix Expression

This algorithm uses a stack to hold operands. When an operator is encountered, it operates on the top two operands from the stack.

**Pseudocode:**
1.  Read the postfix expression from left to right, one symbol at a time.
2.  If the symbol is an **operand**, push it onto the stack.
3.  If the symbol is an **operator**:
    *   Pop the top two operands from the stack (let the first popped be `op2` and the second be `op1`).
    *   Perform the operation: `result = op1 operator op2`.
    *   Push the `result` back onto the stack.
4.  After scanning the entire expression, the final result is the single value remaining in the stack. Pop and return it.

**Detailed Example (from *Internal Test - 1*): Evaluate `3 4 + 5 * 6 -`**

| Symbol Scanned | Operation Description                                                                       | Stack Contents (bottom to top) |
| :------------: | :------------------------------------------------------------------------------------------ | :----------------------------- |
|       `3`        | Operand. Push onto stack.                                                                   | `[3]`                          |
|       `4`        | Operand. Push onto stack.                                                                   | `[3, 4]`                       |
|       `+`        | Operator. Pop 4 (op2), pop 3 (op1). Compute `3 + 4 = 7`. Push result.                         | `[7]`                          |
|       `5`        | Operand. Push onto stack.                                                                   | `[7, 5]`                       |
|       `*`        | Operator. Pop 5 (op2), pop 7 (op1). Compute `7 * 5 = 35`. Push result.                        | `[35]`                         |
|       `6`        | Operand. Push onto stack.                                                                   | `[35, 6]`                      |
|       `-`        | Operator. Pop 6 (op2), pop 35 (op1). Compute `35 - 6 = 29`. Push result.                       | `[29]`                         |

The expression is finished. The final result is the value on the stack: **29**.

---

### Questions

1.  Explain the algorithm to perform the evaluation of a postfix expression using a stack. Demonstrate the process step by step for `3 4 + 5 * 6 -`. (From *Internal Test - 1*)
2.  Write an algorithm to convert an infix expression into its equivalent postfix expression. Convert the expression `((A/(B-D+E)) * (F-G) * H)` to postfix form. Show each step including the stack contents. (From *Internal Test - 1*)
3.  Why is a stack the ideal data structure for converting infix to postfix expressions?
4.  What is the postfix (Reverse Polish Notation) equivalent of the infix expression `E+((A+B)*D)-C`?

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

**Algorithm for Postfix Evaluation:**
1.  Initialize an empty stack.
2.  Scan the postfix expression from left to right.
3.  If the current symbol is an **operand** (a number or variable), push it onto the stack.
4.  If the current symbol is an **operator** (`+`, `-`, `*`, `/`, etc.):
    a. Pop the top element from the stack (this is the second operand, `op2`).
    b. Pop the next element from the stack (this is the first operand, `op1`).
    c. Compute the result of `op1 operator op2`.
    d. Push the result back onto the stack.
5.  After the entire expression has been scanned, the stack will contain a single value, which is the final result.

**Demonstration for `3 4 + 5 * 6 -`:**

| Symbol Scanned | Action                               | Stack                 |
| :------------: | :----------------------------------- | :-------------------- |
|       3        | Push 3                               | `[3]`                 |
|       4        | Push 4                               | `[3, 4]`              |
|       +        | Pop 4, Pop 3. Compute `3+4=7`. Push 7. | `[7]`                 |
|       5        | Push 5                               | `[7, 5]`              |
|       *        | Pop 5, Pop 7. Compute `7*5=35`. Push 35. | `[35]`                |
|       6        | Push 6                               | `[35, 6]`             |
|       -        | Pop 6, Pop 35. Compute `35-6=29`. Push 29. | `[29]`                |

**Final Result:** 29

---

#### Answer to Question 2

**Algorithm for Infix to Postfix Conversion:**
1.  Initialize an empty stack for operators and an empty string for the postfix result.
2.  Scan the infix expression from left to right.
3.  **Operand:** If the symbol is an operand, append it to the result string.
4.  **`(`:** If the symbol is an opening parenthesis, push it onto the stack.
5.  **`)`:** If the symbol is a closing parenthesis, pop operators from the stack and append them to the result until an opening parenthesis `(` is found. Discard the `(`.
6.  **Operator:** If the symbol is an operator, pop and append to the result all operators from the stack that have higher or equal precedence. Then, push the current operator onto the stack.
7.  After scanning, pop and append all remaining operators from the stack to the result.

**Conversion of `((A/(B-D+E)) * (F-G) * H)`:**

| Symbol | Stack Content (bottom->top) | Postfix Expression              |
| :----: | :-------------------------- | :------------------------------ |
|   (    | `(`                         |                                 |
|   (    | `( (`                       |                                 |
|   A    | `( (`                       | `A`                             |
|   /    | `( (/`                      | `A`                             |
|   (    | `( (/( `                    | `A`                             |
|   B    | `( (/( `                    | `A B`                           |
|   -    | `( (/( -`                   | `A B`                           |
|   D    | `( (/( -`                   | `A B D`                         |
|   )    | `( (/`                      | `A B D -`                       |
|   +    | `( (/ +`                    | `A B D -`                       |
|   E    | `( (/ +`                    | `A B D - E`                     |
|   )    | `(`                         | `A B D - E + /`                 |
|   )    |                             | `A B D - E + /`                 |
|   *    | `*`                         | `A B D - E + /`                 |
|   (    | `* (`                       | `A B D - E + /`                 |
|   F    | `* (`                       | `A B D - E + / F`               |
|   -    | `* ( -`                     | `A B D - E + / F`               |
|   G    | `* ( -`                     | `A B D - E + / F G`             |
|   )    | `*`                         | `A B D - E + / F G -`           |
|   *    | `*`                         | `A B D - E + / F G -`           |
|   H    | `*`                         | `A B D - E + / F G - H`         |
|  end   |                             | `A B D - E + / F G - H * *`     |

**Final Postfix Expression:** `A B D - E + / F G - * H *`

---

#### Answer to Question 3

A stack is the ideal data structure because its **LIFO (Last-In-First-Out)** nature perfectly mirrors the requirements of handling operator precedence and parentheses.

1.  **Handling Precedence:** When converting `A + B * C`, the `+` is pushed onto the stack. When the `*` arrives, since it has higher precedence, it can be pushed on top of the `+`. When the expression ends, the operators are popped in the correct order: `*` first, then `+`, resulting in `A B C * +`. The stack naturally reverses the order of operators based on when they need to be evaluated.

2.  **Handling Parentheses:** Parentheses create nested sub-expressions that must be evaluated first. A stack manages this nesting perfectly. When an opening parenthesis `(` is found, it's pushed, creating a new, isolated context for operators inside it. When the closing parenthesis `)` is found, all operators up to the matching `(` are popped. This ensures the sub-expression is fully resolved before moving on, perfectly mirroring the LIFO behavior of nested scopes.

---

#### Answer to Question 4

The infix expression is `E+((A+B)*D)-C`. Let's convert it step-by-step:
1. `(A+B)` -> `AB+`
2. `(AB+)*D` -> `AB+D*`
3. `E+(AB+D*)` -> `EAB+D*+`
4. `(EAB+D*+)-C` -> `EAB+D*+C-`

The correct postfix notation is **`EAB+D*+C-`**.

</details>
