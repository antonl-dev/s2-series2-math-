# Module 2: Arrays and Linked List

## 2.2.a Circular Queues

### 1. Why We Need Circular Queues

As discussed in the previous section, a simple linear queue implemented with an array has a major flaw: **it wastes space**. As elements are dequeued, the `front` pointer moves forward, and the space at the beginning of the array becomes unusable. A circular queue solves this problem by allowing the queue to "wrap around" the end of the array.

### 2. How a Circular Queue Works

A circular queue treats the array as if it were a circle, where the last element is connected back to the first. This is achieved by using the **modulo operator (`%`)** during insertion and deletion. When the `front` or `rear` pointer reaches the end of the array, the modulo operation causes it to wrap around to index `0`.

This allows the queue to efficiently reuse the empty spaces left at the beginning of the array after dequeue operations.

[Click here for an animation of a Circular Queue](https://www.google.com/search?tbm=isch&q=circular+queue+array+animation+gif)
**What to look for:** An animation showing the `rear` pointer moving. When it reaches the end of the array, watch it "wrap around" to the beginning to insert new elements into the empty slots left by previous `dequeue` operations.

### 3. Conditions for Empty and Full States

In a circular queue, the conditions for checking if the queue is empty or full are slightly different from a linear queue.

*   **Empty Condition:** Same as a linear queue. The queue is empty when `front` is `-1`.
    `if (front == -1)`

*   **Full Condition:** A queue is full when the `rear` pointer is one position behind the `front` pointer in a circular manner. This happens when `(rear + 1) % MAX_SIZE` is equal to `front`.
    `if ((rear + 1) % MAX_SIZE == front)`

### 4. Algorithm for `enqueue(value)` (Insertion)

This algorithm adds an element to the rear of the circular queue.

**Pseudocode:**
```
Step 1: IF (rear + 1) % MAX_SIZE == front
           PRINT "OVERFLOW"
           Exit
        [END OF IF]
Step 2: IF front == -1 AND rear == -1
           SET front = 0
           SET rear = 0
        ELSE
           SET rear = (rear + 1) % MAX_SIZE
        [END OF IF]
Step 3: SET QUEUE[rear] = value
```

**Detailed Line-by-Line Explanation:**

*   **`Step 1: IF (rear + 1) % MAX_SIZE == front`**
    *   **Purpose:** This is the crucial check to see if the queue is full.
    *   **Why?** In a circular queue, the only time the `rear` pointer (after being incremented) would "catch up" to the `front` pointer is when all slots are filled. The modulo `% MAX_SIZE` ensures this check works even when `rear` is at the end of the array and needs to wrap around to `0`. If this condition is true, we cannot add more elements.

*   **`Step 2: IF front == -1 AND rear == -1`**
    *   **Purpose:** This handles the special case of inserting the very first element into an empty queue.
    *   **Why?** An empty queue is represented by `front = -1` and `rear = -1`. Before inserting the first element, we must initialize both pointers to a valid starting index, which is `0`.

*   **`Step 2 (ELSE): SET rear = (rear + 1) % MAX_SIZE`**
    *   **Purpose:** This is the standard step for advancing the `rear` pointer.
    *   **Why?** Instead of just `rear = rear + 1`, we use the modulo operator. This is the "circular" part. If `rear` is at the last index (e.g., `MAX_SIZE - 1`), `(rear + 1)` becomes `MAX_SIZE`, and `MAX_SIZE % MAX_SIZE` is `0`, effectively wrapping the pointer back to the start of the array. For any other index, it works just like a simple increment.

*   **`Step 3: SET QUEUE[rear] = value`**
    *   **Purpose:** Inserts the new value into the array.
    *   **Why?** After the `rear` pointer has been moved to its new correct position (either by incrementing or wrapping around), this statement places the value at that empty slot.

### 5. Algorithm for `dequeue()` (Deletion)

This algorithm removes an element from the front of the circular queue.

**Pseudocode:**
```
Step 1: IF front == -1
           PRINT "UNDERFLOW"
           Exit
        [END OF IF]
Step 2: SET value = QUEUE[front]
Step 3: IF front == rear
           SET front = -1
           SET rear = -1
        ELSE
           SET front = (front + 1) % MAX_SIZE
        [END OF IF]
Step 4: RETURN value
```

**Detailed Line-by-Line Explanation:**

*   **`Step 1: IF front == -1`**
    *   **Purpose:** Checks if the queue is empty.
    *   **Why?** `front = -1` is our designated state for an empty queue. If it's empty, there is nothing to remove, so we report an "UNDERFLOW" error.

*   **`Step 2: SET value = QUEUE[front]`**
    *   **Purpose:** Retrieves the element to be removed.
    *   **Why?** In a FIFO structure, the element at the `front` is always the one to be removed. We store its value in a variable so we can return it after adjusting the pointers.

*   **`Step 3: IF front == rear`**
    *   **Purpose:** This handles the special case where we are removing the *last* remaining element from the queue.
    *   **Why?** If `front` and `rear` are at the same index, it means there is only one element. After removing it, the queue will be empty. We must reset both pointers back to `-1` to reflect this empty state.

*   **`Step 3 (ELSE): SET front = (front + 1) % MAX_SIZE`**
    *   **Purpose:** This is the standard step for advancing the `front` pointer.
    *   **Why?** Similar to `enqueue`, using the modulo operator allows the `front` pointer to wrap around to index `0` if it was at the last index of the array, effectively reusing the array space in a circular fashion.

---

### Questions

1.  What is the primary problem with a simple linear queue that a circular queue solves?
2.  Explain the role of the modulo (`%`) operator in a circular queue.
3.  Write the algorithm for `enqueue()` in a circular queue and explain the logic for the "full" condition.
4.  Why is it necessary to check if `front == rear` during a `dequeue` operation in a circular queue?

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

The primary problem with a simple linear queue implemented in an array is the **inefficient use of space**. As elements are dequeued from the front, the `front` index moves forward, leaving empty, unusable slots at the beginning of the array. Even if the queue is logically empty or has free space, it might report an "overflow" condition if the `rear` index has reached the end of the array. A circular queue solves this by "wrapping around" the array, allowing it to reuse these empty slots.

---

#### Answer to Question 2

The modulo (`%`) operator is the core mechanism that enables the "wrap-around" behavior of a circular queue. When updating the `front` or `rear` pointers, the formula `(pointer + 1) % MAX_SIZE` is used.

*   **Normal Case:** If `pointer + 1` is less than `MAX_SIZE`, the result is simply `pointer + 1`.
*   **Wrap-around Case:** If the pointer is at the last index (`MAX_SIZE - 1`), then `pointer + 1` becomes `MAX_SIZE`. The expression `MAX_SIZE % MAX_SIZE` evaluates to `0`, causing the pointer to jump back to the beginning of the array. This allows the queue to use any empty slots at the start of the array.

---

#### Answer to Question 3

**Algorithm for `enqueue()`:**
```
Step 1: Check for overflow: IF (rear + 1) % MAX_SIZE == front, PRINT "OVERFLOW" and exit.
Step 2: If inserting the first element (front == -1), SET front = 0 and rear = 0.
Step 3: ELSE, update rear: SET rear = (rear + 1) % MAX_SIZE.
Step 4: Insert element: SET QUEUE[rear] = value.
```

**Logic for the "Full" Condition `(rear + 1) % MAX_SIZE == front`:**
A circular queue is full when the `rear` pointer is one position *behind* the `front` pointer. The expression `(rear + 1) % MAX_SIZE` calculates the next potential position for `rear`. If this new position is the same as where `front` is currently located, it means there is no usable space left between `rear` and `front`, and thus the queue is full. This implementation method effectively leaves one slot empty to differentiate a full state from an empty state.

---

#### Answer to Question 4

It is necessary to check if `front == rear` during a `dequeue` operation to handle the special case of removing the **last element** from the queue.

If `front` and `rear` point to the same index, it means there is only one element left. When this element is dequeued, the queue becomes empty. If we simply advanced the `front` pointer using `(front + 1) % MAX_SIZE`, the `front` and `rear` pointers would be out of sync and would not correctly represent an empty state. By explicitly checking for `front == rear`, we can correctly reset both `front` and `rear` to `-1`, which is the defined state for an empty queue.

</details>
