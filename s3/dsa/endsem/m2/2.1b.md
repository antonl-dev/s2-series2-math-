# Module 2: Arrays and Linked List

## 2.1.b Queues (Array Implementation)

A **Queue** is a linear data structure that follows the **FIFO (First-In, First-Out)** principle. This means the first element added to the queue will be the first one to be removed.

The most common analogy is a line of people waiting at a counter: the first person to get in line is the first person to be served.

*   Elements are inserted at one end, called the **`rear`** (or tail).
*   Elements are removed from the opposite end, called the **`front`** (or head).

[Click here for a diagram of a Queue (FIFO)](https://www.google.com/search?tbm=isch&q=queue+data+structure+FIFO+enqueue+dequeue)
**What to look for:** A visual showing elements being added (enqueued) to the back (`rear`) of a horizontal line and being removed (dequeued) from the front (`front`).

### Key Queue Operations (ADT)

*   **`enqueue(item)`:** Inserts an element at the `rear` of the queue. If the queue is full, this results in an **Overflow** condition.
*   **`dequeue()`:** Deletes and returns the element from the `front` of the queue. If the queue is empty, this results in an **Underflow** condition.
*   **`isEmpty()`:** Checks if the queue is empty.
*   **`isFull()`:** Checks if the queue is full.

### Array Implementation of a Simple Queue

A simple queue can be implemented using a one-dimensional array and two integer variables to keep track of the ends.

*   **Structure:** An array (e.g., `queue[MAX_SIZE]`) to store the elements.
*   **Pointers:** Two integer variables, `front` and `rear`, are used as indices.
*   **Initialization:** Both `front` and `rear` are initialized to `-1` to indicate that the queue is empty.

### Algorithm for `enqueue(value)` (Insertion)

This algorithm adds an element to the rear of the queue.

**Pseudocode:**
```
Step 1: IF REAR == MAX_SIZE - 1, then
           Write "OVERFLOW"
           Go to Step 4
        [END OF IF]
Step 2: IF FRONT == -1 and REAR == -1, then
           SET FRONT = 0
           SET REAR = 0
        ELSE
           SET REAR = REAR + 1
        [END OF IF]
Step 3: SET QUEUE[REAR] = value
Step 4: Exit
```

**Detailed Line-by-Line Explanation:**

*   **`Step 1: IF REAR == MAX_SIZE - 1`**
    *   **Purpose:** This is the **overflow check** for a simple linear queue.
    *   **Why?** In a basic array implementation, `rear` only moves forward. If it reaches the last possible index (`MAX_SIZE - 1`), we consider the queue full because there are no more slots after it.

*   **`Step 2: IF FRONT == -1 AND REAR == -1`**
    *   **Purpose:** This handles the special case of inserting the **very first element** into an empty queue.
    *   **Why?** An empty queue is represented by `front = -1`. To insert the first element, both `front` and `rear` must point to the first index of the array, which is `0`. This step initializes the queue.

*   **`Step 2 (ELSE): SET REAR = REAR + 1`**
    *   **Purpose:** To move the `rear` pointer to the next available position.
    *   **Why?** For any subsequent insertion (when the queue is not empty), we simply increment `rear` to point to the next empty slot where the new element will be placed.

*   **`Step 3: SET QUEUE[REAR] = value`**
    *   **Purpose:** To place the new element in the queue.
    *   **Why?** After the `rear` pointer has been correctly positioned, this statement inserts the `value` into the array at that new `rear` index.

### Algorithm for `dequeue()` (Deletion)

This algorithm removes and returns the element from the front of the queue.

**Pseudocode:**
```
Step 1: IF FRONT == -1 OR FRONT > REAR, then
           Write "UNDERFLOW"
           Exit
        ELSE
           SET value = QUEUE[FRONT]
           SET FRONT = FRONT + 1
           IF FRONT > REAR THEN
              SET FRONT = REAR = -1
           [END OF IF]
           RETURN value
        [END OF IF]
```

**Detailed Line-by-Line Explanation:**

*   **`Step 1: IF FRONT == -1 OR FRONT > REAR`**
    *   **Purpose:** This is the **underflow check**.
    *   **Why?** There are two conditions for an empty queue here. `FRONT == -1` is the initial empty state. `FRONT > REAR` is a state that occurs after all elements that were in the queue have been dequeued one by one. In either case, there is nothing to remove.

*   **`(ELSE) SET value = QUEUE[FRONT]`**
    *   **Purpose:** To retrieve the element being removed.
    *   **Why?** The `dequeue` operation must return the value that was at the front. We save it in a temporary variable before changing any pointers.

*   **`SET FRONT = FRONT + 1`**
    *   **Purpose:** This is the core "removal" action.
    *   **Why?** In a FIFO queue, we remove from the front. Instead of erasing data, we simply move the `front` of the queue to the next element by incrementing the `front` index. The element at the old `front` index is now logically gone and cannot be accessed.

*   **`IF FRONT > REAR THEN ...`**
    *   **Purpose:** To reset the queue after the last element has been removed.
    *   **Why?** If, after incrementing `front`, it becomes greater than `rear`, it signifies that the single element that was in the queue has just been dequeued. The queue is now empty. This step resets `front` and `rear` back to `-1`, returning the queue to its initial empty state and preventing logical errors.

### The Disadvantage of a Simple Linear Queue

The main drawback of implementing a queue using a simple linear array is **inefficient use of space**.

When elements are dequeued, the `front` pointer is incremented, effectively abandoning the memory locations at the beginning of the array. For example, if we enqueue 5 elements into an array of size 5 and then dequeue all 5, both `front` and `rear` will be at the end of the array. The queue will be logically empty, but because `rear` is at `MAX_SIZE - 1`, the overflow condition will be met, and we cannot add any new elements even though the entire array is available. This wastage of space is solved by using a **Circular Queue**.

---

### Questions

1.  Compare and contrast a Stack and a Queue data structure.
2.  Explain the roles of the `front` and `rear` variables in an array-based queue implementation.
3.  Write the algorithm for the `dequeue` operation in a linear queue and explain in detail why the `front` variable is incremented.
4.  What is the main drawback of a linear queue implementation, and what data structure is used to solve it?

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

| Feature                    | Stack                                             | Queue                                                |
| :------------------------- | :------------------------------------------------ | :--------------------------------------------------- |
| **Principle**              | LIFO (Last-In, First-Out)                         | FIFO (First-In, First-Out)                           |
| **Analogy**                | A pile of plates                                  | A line of people waiting for a service               |
| **Ends Used**              | A single end, called the **`top`**.                 | Two ends: **`front`** for removal, **`rear`** for insertion. |
| **Insertion Operation**    | `push()`                                          | `enqueue()`                                          |
| **Deletion Operation**     | `pop()`                                           | `dequeue()`                                          |
| **Pointer(s)/Index(es)**   | One index: `top`.                               | Two indices: `front` and `rear`.                    |

---

#### Answer to Question 2

In an array-based queue implementation:

*   **`front`:** This variable holds the index of the **first element** in the queue. It is the position from which the next `dequeue` operation will remove an element. When an element is dequeued, `front` is incremented to point to the new first element.

*   **`rear`:** This variable holds the index of the **last element** in the queue. It is the position where the next `enqueue` operation will add a new element. When an element is enqueued, it is placed at the new `rear` position (after `rear` is incremented).

---

#### Answer to Question 3

**Algorithm for `dequeue()` in a linear queue:**
```
Step 1: Check for underflow: IF FRONT == -1 OR FRONT > REAR, print "UNDERFLOW" and exit.
Step 2: Retrieve the value: SET value = QUEUE[FRONT].
Step 3: Increment the front pointer: SET FRONT = FRONT + 1.
Step 4: Check if the queue is now empty: IF FRONT > REAR, reset pointers: SET FRONT = -1, SET REAR = -1.
Step 5: Return the retrieved value.
```
**Why `front` is incremented:**
The `front` variable marks the beginning of the queue. The `dequeue` operation must remove the element at this position because a queue is a First-In-First-Out (FIFO) structure. Instead of physically erasing the element from the array (which would be an inefficient O(n) operation if we shifted all other elements), we perform a logical removal. By simply incrementing `front` (`FRONT = FRONT + 1`), we are stating that the "start of the line" has moved to the next element. The previous element at the old `front` index is now effectively discarded and can no longer be accessed by queue operations. This is a highly efficient O(1) way to "remove" the element.

---

#### Answer to Question 4

The main drawback of a linear queue implementation is **inefficient use of space**. As elements are dequeued, the space at the beginning of the array becomes unusable. This can lead to a false "overflow" condition where the queue is unable to accept new elements because the `rear` index has reached the end of the array, even though there might be plenty of empty space at the beginning.

This problem is solved by using a **Circular Queue**, which treats the array as circular and reuses the empty space at the beginning.

</details>
