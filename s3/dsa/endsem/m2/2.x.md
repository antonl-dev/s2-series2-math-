### `2.x.md`

# Module 2: Comprehensive Questions - Arrays and Linked Lists

### Section 1: Stacks and Queues (Array-Based)

1.  **Define Stack:** What is a stack? Explain the LIFO principle with a real-world analogy. List the primary operations of a stack.
2.  **Define Queue:** What is a queue? Explain the FIFO principle with a real-world analogy.
3.  **Stack Implementation:** Write the algorithm/pseudocode for the `push()` and `pop()` operations for a stack implemented using an array. Mention how to check for overflow and underflow conditions.
4.  **Circular Queue:** What is a circular queue and why is it an improvement over a linear queue? Explain how the `front` and `rear` pointers are managed, including the condition for a full queue.
5.  **Deque:** What is a Double-Ended Queue (Deque)? Describe the four main operations associated with it.

### Section 2: Linked Lists

6.  **Singly vs. Doubly Linked List:** Differentiate between a singly linked list and a doubly linked list. What is the main advantage of a doubly linked list?
7.  **Self-Referential Structures:** Explain what a self-referential structure is and why it is fundamental to implementing linked lists in C. Provide the C `struct` definition for a singly linked list node.
8.  **Insertion in Singly Linked List:** Write a C function or detailed algorithm to insert a new node at a specific position in a singly linked list. Handle the edge cases of inserting at the beginning and an invalid position.
9.  **Deletion from End (Singly LL):** Explain the process and complexity of deleting the last node from a singly linked list. Why is this operation less efficient than deleting from the beginning?
10. **Circular Linked List:** What is a circular linked list? How does its structure differ from a standard singly linked list? What is the main advantage of this structure?

### Section 3: Applications and Implementations

11. **Infix to Postfix Conversion:** Convert the following infix expression to its postfix equivalent using a stack. Show the state of the stack and the output expression at each step.
    `A * (B + C) / D - E`
12. **Postfix Expression Evaluation:** Evaluate the following postfix expression using a stack. Show the state of the stack after each operation.
    `8 2 + 3 * 4 / 2 -`
13. **Stack using Linked List:** What are the advantages of implementing a stack using a linked list instead of an array? Write the algorithm for the `push()` operation for a linked list-based stack.
14. **Queue using Linked List:** Explain how a queue can be implemented using a linked list. Which ends of the list would you use for `enqueue` and `dequeue` to ensure efficiency?
15. **Polynomial Addition:** Explain the algorithm for adding two polynomials that are represented using singly linked lists. Each node in the list stores a coefficient and an exponent.

---

### `2.xa.md`

# Module 2: Answer Key - Arrays and Linked Lists

<details>
<summary>1. <strong>Define Stack:</strong> What is a stack? Explain the LIFO principle with a real-world analogy. List the primary operations of a stack.</summary>

A **stack** is a linear data structure that follows the **Last-In, First-Out (LIFO)** principle. This means the last element added to the stack is the first element to be removed.

*   **LIFO Analogy:** A stack of plates. You place a new plate on the top of the stack, and when you need a plate, you take one from the top. The last plate you put on is the first one you take off.

*   **Primary Operations:**
    *   `push(value)`: Adds an element to the top of the stack.
    *   `pop()`: Removes and returns the element from the top of the stack.
    *   `peek()` (or `top()`): Returns the top element without removing it.
    *   `isEmpty()`: Checks if the stack is empty.
    *   `isFull()`: Checks if the stack is full (relevant for array-based implementations).
</details>

<details>
<summary>2. <strong>Define Queue:</strong> What is a queue? Explain the FIFO principle with a real-world analogy.</summary>

A **queue** is a linear data structure that follows the **First-In, First-Out (FIFO)** principle. This means the first element added to the queue is the first element to be removed.

*   **FIFO Analogy:** A line of people at a ticket counter. The first person to get in line is the first person to be served and leave the line. Elements are added at one end (the **rear**) and removed from the other end (the **front**).
</details>

<details>
<summary>3. <strong>Stack Implementation:</strong> Write the algorithm/pseudocode for the `push()` and `pop()` operations for a stack implemented using an array. Mention how to check for overflow and underflow conditions.</summary>

Let `stack[]` be the array, `top` be the index of the top element (initialized to -1), and `MAX_SIZE` be the size of the array.

**push(value):**
1.  Check for stack overflow: `if top >= MAX_SIZE - 1`
2.  If true, print "Stack Overflow" and exit.
3.  If false, increment `top`: `top = top + 1`.
4.  Add the element to the stack: `stack[top] = value`.

**pop():**
1.  Check for stack underflow: `if top < 0`
2.  If true, print "Stack Underflow" and exit.
3.  If false, retrieve the top element: `value = stack[top]`.
4.  Decrement `top`: `top = top - 1`.
5.  Return `value`.
</details>

<details>
<summary>4. <strong>Circular Queue:</strong> What is a circular queue and why is it an improvement over a linear queue?</summary>

A **circular queue** is a linear data structure in which the operations are performed based on the FIFO principle, but the last position is connected back to the first position to form a circle. It is an improvement over a linear queue because it efficiently utilizes the memory space. In a linear queue, once the `rear` pointer reaches the end of the array, no more elements can be inserted, even if there are empty spaces at the beginning of the array. A circular queue solves this by "wrapping around."

**Pointer Management:**
*   **Enqueue (insert):** `rear = (rear + 1) % MAX_SIZE`
*   **Dequeue (delete):** `front = (front + 1) % MAX_SIZE`
*   **Full Condition:** The queue is full when `(rear + 1) % MAX_SIZE == front`.
*   **Empty Condition:** The queue is empty when `front == rear` (or `front == -1`).
</details>

<details>
<summary>5. <strong>Deque:</strong> What is a Double-Ended Queue (Deque)? Describe the four main operations associated with it.</summary>

A **Deque (Double-Ended Queue)** is a generalized version of a queue where insertion and deletion can happen at both endsâ€”the front and the rear.

**Main Operations:**
1.  **Insert at Front:** Adds an item to the front of the deque.
2.  **Insert at Rear:** Adds an item to the rear of the deque.
3.  **Delete from Front:** Removes an item from the front of the deque.
4.  **Delete from Rear:** Removes an item from the rear of the deque.
</details>

<details>
<summary>6. <strong>Singly vs. Doubly Linked List:</strong> Differentiate between a singly linked list and a doubly linked list. What is the main advantage of a doubly linked list?</summary>

*   **Singly Linked List:**
    *   Each node contains data and a single pointer (`next`) that points to the next node in the sequence.
    *   Traversal is only possible in the forward direction.
    *   Requires less memory per node (one pointer).

*   **Doubly Linked List:**
    *   Each node contains data and two pointers: `next` (points to the next node) and `prev` (points to the previous node).
    *   Traversal is possible in both forward and backward directions.
    *   Requires more memory per node (two pointers).

*   **Main Advantage of Doubly Linked List:** The ability to traverse backward. This makes certain operations, like deleting a node without needing a pointer to its predecessor, much more efficient.
</details>

<details>
<summary>7. <strong>Self-Referential Structures:</strong> Explain what a self-referential structure is and why it is fundamental to implementing linked lists in C.</summary>

A **self-referential structure** is a C `struct` that contains a member which is a pointer to another structure of the same type. This "self-reference" is what allows nodes in a linked list to point to each other, forming a chain. Without this capability, you could not create a dynamic link between one node and the next.

**C `struct` for a singly linked list node:**
```c
// Define the Node structure
struct Node {
    int data;            // The data stored in the node
    struct Node* link;   // A pointer to the next node of the same type
};
```
Here, the `link` member is a pointer to `struct Node`, making it a self-referential structure.
</details>

<details>
<summary>8. <strong>Insertion in Singly Linked List:</strong> Write a C function or detailed algorithm to insert a new node at a specific position in a singly linked list.</summary>

```c
// 'start' is a pointer to the head of the list.
void insertAtPosition(struct Node** start, int data, int position) {
    // 1. Create the new node
    struct Node* newNode = createNode(data);

    // 2. Handle insertion at the beginning (position 0)
    if (position == 0) {
        newNode->link = *start;
        *start = newNode;
        return;
    }

    // 3. Traverse to the node *before* the target position
    struct Node* temp = *start;
    for (int i = 0; temp != NULL && i < position - 1; i++) {
        temp = temp->link;
    }

    // 4. Check if the position is valid
    if (temp == NULL) {
        printf("Position out of range\n");
        free(newNode); // Avoid memory leak
        return;
    }

    // 5. Link the new node into the list
    newNode->link = temp->link;
    temp->link = newNode;
}
```
</details>

<details>
<summary>9. <strong>Deletion from End (Singly LL):</strong> Explain the process and complexity of deleting the last node from a singly linked list.</summary>

**Process:**
To delete the last node, you must find the **second-to-last** node, because its `link` pointer needs to be set to `NULL`.
1.  Handle edge cases: If the list is empty, there's nothing to do. If the list has only one node, set the head pointer to `NULL` and free the node.
2.  Traverse the list from the `start` until you find the node whose `link->link` is `NULL`. This node is the second-to-last node.
3.  Store a pointer to the last node (`temp->link`).
4.  Set the `link` of the second-to-last node to `NULL`.
5.  Free the memory of the last node.

**Complexity:**
The time complexity is **O(n)** because you must traverse the entire list to find the second-to-last node. This is inefficient compared to deleting from the beginning, which is an **O(1)** operation as it only involves redirecting the `start` pointer.
</details>

<details>
<summary>10. <strong>Circular Linked List:</strong> What is a circular linked list? How does its structure differ from a standard singly linked list? What is the main advantage of this structure?</summary>

A **circular linked list** is a variation of a linked list in which the last node points back to the first node, forming a circle.

*   **Structural Difference:** In a standard singly linked list, the `link` of the last node is `NULL`. In a circular linked list, the `link` of the last node points to the `start` node.

*   **Main Advantage:** You can traverse the entire list starting from any node. It is also useful for implementing a queue efficiently. By maintaining only a pointer to the `last` node, you can access both the last node (for `enqueue`) and the first node (`last->link`, for `dequeue`) in O(1) time.
</details>

<details>
<summary>11. <strong>Infix to Postfix Conversion:</strong> `A * (B + C) / D - E`</summary>

| Symbol | Stack | Output Expression |
| :----: | :---: | :---------------- |
| A      |       | A                 |
| *      | *     | A                 |
| (      | *(    | A                 |
| B      | *(    | A B               |
| +      | *(+   | A B               |
| C      | *(+   | A B C             |
| )      | *     | A B C +           |
| /      | /     | A B C + *         |
| D      | /     | A B C + * D       |
| (end)  | -     | A B C + * D /     |
| E      | -     | A B C + * D / E   |
| (end)  |       | A B C + * D / E - |

**Final Postfix Expression:** `A B C + * D / E -`
</details>

<details>
<summary>12. <strong>Postfix Expression Evaluation:</strong> `8 2 + 3 * 4 / 2 -`</summary>

| Token | Stack (Bottom -> Top) | Action |
| :---: | :-------------------- | :--- |
| 8     | [8]                   | Push 8 |
| 2     | [8, 2]                | Push 2 |
| +     | [10]                  | Pop 2, Pop 8. Push (8+2)=10 |
| 3     | [10, 3]               | Push 3 |
| *     | [30]                  | Pop 3, Pop 10. Push (10*3)=30 |
| 4     | [30, 4]               | Push 4 |
| /     | [7]                   | Pop 4, Pop 30. Push (30/4)=7 (integer division) |
| 2     | [7, 2]                | Push 2 |
| -     | [5]                   | Pop 2, Pop 7. Push (7-2)=5 |

**Final Result:** `5`
</details>

<details>
<summary>13. <strong>Stack using Linked List:</strong> What are the advantages of implementing a stack using a linked list instead of an array?</summary>

The main advantage is **dynamic size**.
*   **No Overflow:** An array-based stack has a fixed size and can overflow if more elements are pushed than the array can hold. A linked list-based stack can grow as long as there is available memory, so it will not overflow.
*   **Memory Efficiency:** With an array, you must allocate a potentially large block of memory upfront, which may be wasted if the stack doesn't grow large. With a linked list, memory is allocated one node at a time as needed.

**Algorithm for `push(value)`:**
1.  Create a new node.
2.  Set the `data` field of the new node to `value`.
3.  Set the `link` field of the new node to point to the current `top` of the stack.
4.  Update the `top` pointer to point to the new node.
</details>

<details>
<summary>14. <strong>Queue using Linked List:</strong> Explain how a queue can be implemented using a linked list.</summary>

A queue is implemented using a linked list by maintaining two pointers: `front` (pointing to the head) and `rear` (pointing to the tail).

*   **`enqueue(value)` (Insert at Rear):** This operation is most efficient if done at the end of the list.
    1.  Create a new node with the given value.
    2.  If the queue is empty (`front` is `NULL`), set both `front` and `rear` to the new node.
    3.  Otherwise, set the `link` of the current `rear` node to the new node.
    4.  Update the `rear` pointer to be the new node.
    This is an **O(1)** operation.

*   **`dequeue()` (Delete from Front):** This operation is done at the beginning of the list.
    1.  Check if the queue is empty.
    2.  Store a temporary pointer to the `front` node.
    3.  Move the `front` pointer to the next node (`front = front->link`).
    4.  If the queue becomes empty after this, also set `rear` to `NULL`.
    5.  Free the memory of the temporary node.
    This is also an **O(1)** operation.
</details>

<details>
<summary>15. <strong>Polynomial Addition:</strong> Explain the algorithm for adding two polynomials that are represented using singly linked lists.</summary>

**Representation:** Each node stores a `coef` (coefficient) and an `exp` (exponent), sorted in descending order of exponents.

**Algorithm:**
1.  Create a new empty linked list for the `result`.
2.  Use two pointers, `p1` and `p2`, to traverse the two polynomial lists (`poly1` and `poly2`).
3.  Iterate while both `p1` and `p2` are not `NULL`:
    *   **If `p1->exp > p2->exp`:** Add the term from `p1` to the `result` list and advance `p1`.
    *   **If `p2->exp > p1->exp`:** Add the term from `p2` to the `result` list and advance `p2`.
    *   **If `p1->exp == p2->exp`:** Add the coefficients (`p1->coef + p2->coef`). If the sum is not zero, create a new node with this sum and the common exponent and add it to the `result` list. Advance both `p1` and `p2`.
4.  After the loop, one of the lists may still have remaining terms. Append all remaining terms from the non-empty list to the `result` list.
5.  Return the `result` list.
</details>
