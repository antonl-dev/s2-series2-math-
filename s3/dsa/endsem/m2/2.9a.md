# Module 2: Arrays and Linked List

## 2.8.a Applications and Searching

This section covers common applications of arrays and linked lists and introduces two fundamental searching algorithms: Linear Search and Binary Search.

### 1. Applications of Arrays

Arrays are one of the most basic and widely used data structures due to their simplicity and efficient O(1) random access.

*   **Implementing other Data Structures:** Arrays are often used as the underlying structure for more complex data structures like **Stacks**, **Queues**, **Deques**, and **Hash Tables**.
*   **Look-up Tables:** Used for storing pre-calculated values that can be accessed quickly by index, such as sine/cosine tables or lookup tables in cryptography.
*   **Representing Matrices:** 2D arrays are the natural way to represent matrices for mathematical and scientific computing.
*   **Sorting Algorithms:** Many sorting algorithms like Bubble Sort, Insertion Sort, and Quick Sort operate directly on arrays.

### 2. Applications of Linked Lists

Linked lists excel where dynamic size and efficient insertions/deletions are more important than random access.

*   **Implementing other Data Structures:** Linked lists are used to implement **Stacks**, **Queues**, and especially **Hash Tables** (for collision handling via chaining).
*   **Dynamic Memory Management:** Used in operating systems to manage free blocks of memory (a "free list").
*   **Music Players/Playlists:** A circular linked list is perfect for creating a playlist that can easily have songs added, removed, or reordered, and can loop back to the beginning.
*   **Undo/Redo Functionality:** The sequence of actions in an editor can be stored in a doubly linked list, allowing the user to move forward and backward through their changes.

### 3. Searching Algorithms

Searching is the process of finding a specific element within a collection of data.

#### a) Linear Search (Sequential Search)

Linear search is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.

*   **Works on:** Both sorted and **unsorted** arrays/lists.
*   **Time Complexity:** **O(n)**. In the worst case, we have to check every single element.
*   **Space Complexity:** **O(1)**. It requires no extra memory.

**Algorithm for Linear Search:**
```
Step 1: Start from the first element of the list (index 0).
Step 2: Compare the current element with the target element (the 'key').
Step 3: IF the elements match, return the current index (element found).
Step 4: IF they do not match, move to the next element.
Step 5: Repeat steps 2-4 until the end of the list is reached.
Step 6: IF the end of the list is reached and no match is found, return -1 (element not found).
```

[Click here for an animation of Linear Search](https://www.google.com/search?tbm=isch&q=linear+search+visualization+gif)
**What to look for:** A visual showing a pointer or highlighter moving one-by-one through an array, comparing each element against the target value.

#### b) Binary Search

Binary search is a much more efficient searching algorithm, but it has a critical requirement: the list **must be sorted**.

It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half.

*   **Works on:** **Sorted** arrays only.
*   **Time Complexity:** **O(log n)**. With each comparison, we eliminate half of the remaining elements, making it extremely fast for large datasets.
*   **Space Complexity:** **O(1)** for the iterative version.

**Algorithm for Binary Search (Iterative):**
```
Step 1: Initialize two pointers, low = 0 and high = n-1.
Step 2: WHILE low <= high:
           a. Calculate the middle index: mid = low + (high - low) / 2.
           b. IF array[mid] == key, return mid (element found).
           c. IF array[mid] < key, the key must be in the right half. SET low = mid + 1.
           d. ELSE (array[mid] > key), the key must be in the left half. SET high = mid - 1.
        [END OF WHILE]
Step 3: IF the loop finishes, the element is not in the array. RETURN -1.
```
**Detailed Explanation of `mid` calculation:**
*   **`mid = low + (high - low) / 2`**: This is a robust way to calculate the middle index. It is preferred over `mid = (low + high) / 2` because the latter can cause an integer overflow if `low` and `high` are very large positive numbers.

[Click here for an animation of Binary Search](https://www.google.com/search?tbm=isch&q=binary+search+visualization+gif)
**What to look for:** A visual showing a sorted array. The algorithm first checks the middle element. Based on the comparison, it discards one half of the array and repeats the process on the remaining half.

---

### Questions

1.  Explain the difference between linear search and binary search, including their time complexities and prerequisites.
2.  A hospital stores patient IDs in an unsorted list. When a new patient comes, the system needs to quickly verify whether the ID already exists. Which searching technique (Linear or Binary Search) is more appropriate? Why? (From *Internal Test - 2*)
3.  Why is an array a suitable data structure for implementing a hash table, while a linked list is better for managing a music playlist?
4.  Write the algorithm for an iterative binary search.

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

| Feature            | Linear Search                                       | Binary Search                                                  |
| :----------------- | :-------------------------------------------------- | :------------------------------------------------------------- |
| **Prerequisite**   | Works on any list, **sorted or unsorted**.          | Requires the list to be **sorted**.                            |
| **Method**         | Sequential. Checks elements one by one from the start. | Divide and Conquer. Checks the middle element and eliminates half the list with each comparison. |
| **Time Complexity**| **O(n)**. The time taken is proportional to the list size. | **O(log n)**. The time taken grows logarithmically, making it much faster for large lists. |
| **Space Complexity**| O(1)                                                | O(1) for the iterative version.                                |

---

#### Answer to Question 2

The more appropriate searching technique is **Linear Search**.

**Reason:**
The key prerequisite for Binary Search is that the data must be **sorted**. The problem explicitly states that the patient IDs are stored in an **unsorted list**. Because the list is unsorted, binary search cannot be applied.

Linear search is the only option. It will have to scan the list from the beginning until it either finds a matching ID or reaches the end of the list. While it is less efficient (O(n)) than binary search, it is the only correct choice for unsorted data. (To improve performance, the hospital would need to maintain the list in a sorted order or use a different data structure like a hash set).

---

#### Answer to Question 3

The suitability of a data structure depends on the primary operations it needs to support.

*   **Array for a Hash Table:** A hash table's core concept is to map a key to an index in an array for direct access. Arrays provide **O(1) random access**, which is essential for this mapping. When a hash function calculates an index `i`, we need to be able to jump directly to `table[i]`, which is exactly what arrays are optimized for.

*   **Linked List for a Music Playlist:** A playlist requires frequent dynamic changes: adding songs, removing them, and reordering them.
    *   **Dynamic Size:** The playlist can have any number of songs.
    *   **Efficient Insertion/Deletion:** A user can add or remove a song from anywhere in the playlist. This is an O(1) operation in a linked list (if the node location is known), whereas in an array it would be a slow O(n) operation due to shifting.
    *   A **circular doubly linked list** is even better, as it allows for "next" and "previous" track functionality and can loop the playlist automatically.

---

#### Answer to Question 4

**Algorithm for Iterative Binary Search:**
This algorithm searches for a `key` in a sorted `array` of size `n`.

1.  Initialize three variables: `low = 0`, `high = n - 1`.
2.  Start a loop that continues as long as `low <= high`.
3.  Inside the loop, calculate the middle index: `mid = low + (high - low) / 2`.
4.  Compare the element at the middle index with the key:
    *   If `array[mid] == key`, the element has been found. Return `mid`.
    *   If `array[mid] < key`, the key must be in the right half of the current search space. Update `low` to `mid + 1`.
    *   If `array[mid] > key`, the key must be in the left half. Update `high` to `mid - 1`.
5.  If the loop terminates (meaning `low > high`), the element is not present in the array. Return `-1`.

</details>
