# Module 2: Arrays and Linked List

## 2.6.a Doubly Linked List

### 1. What is a Doubly Linked List?

A **Doubly Linked List (DLL)** is a more advanced type of linked list where each node has **two pointers**:
1.  **`next` (or `link`):** Points to the next node in the sequence (like in a singly linked list).
2.  **`prev`:** Points to the **previous** node in the sequence.

This bidirectional linking allows for traversal in both forward and backward directions.

[Click here for a diagram of a Doubly Linked List](https://www.google.com/search?tbm=isch&q=doubly+linked+list+diagram+prev+next)
**What to look for:** A chain of nodes where each node has two arrows pointing out of it: one pointing to the node on its right (`next`) and one pointing to the node on its left (`prev`). The `prev` pointer of the head node and the `next` pointer of the last node both point to `NULL`.

### 2. Node Structure in C

The self-referential structure for a DLL node includes two pointers.

```c
struct Node {
    int data;
    struct Node* prev; // Pointer to the previous node
    struct Node* link; // Pointer to the next node
};
```

### 3. Advantages and Disadvantages

**Advantages over a Singly Linked List:**
*   **Bidirectional Traversal:** The list can be traversed both forwards and backwards.
*   **Efficient Deletion:** Deleting a node is more efficient if you have a pointer to the node itself. You don't need to traverse to find the *previous* node, as you have a `prev` pointer already.

**Disadvantages:**
*   **Extra Memory:** Each node requires extra memory to store the `prev` pointer.
*   **More Complex Operations:** Insertion and deletion operations are more complex because they require updating more pointers (typically four pointer updates for an insertion/deletion in the middle, compared to two in an SLL).

### 4. Insertion Operations

#### a) Insertion at the Beginning

**Algorithm for `insertAtBeginning(value)`:**
```
Step 1: Create a new node: SET newNode = createNode(value).
Step 2: IF head == NULL (list is empty)
           SET head = newNode
           Exit
        [END OF IF]
Step 3: SET newNode->link = head  // New node's 'next' points to old head
Step 4: SET head->prev = newNode    // Old head's 'prev' points back to new node
Step 5: SET head = newNode        // Update head to be the new node
```
**Detailed Explanation:**
*   **`Step 1 & 2`**: Standard node creation and check for an empty list.
*   **`Step 3: SET newNode->link = head`**: The forward link of the new node is set to point to the current first node, linking it into the front of the list.
*   **`Step 4: SET head->prev = newNode`**: This is the crucial step for a DLL. The `prev` pointer of the *original* head node must now be updated to point back to our `newNode`. This establishes the backward link.
*   **`Step 5: SET head = newNode`**: The list's main `head` pointer is updated to point to the `newNode`, making it the official new start of the list.

#### b) Insertion at the End

**Algorithm for `insertAtEnd(value)`:**
```
Step 1: Create a new node: SET newNode = createNode(value).
Step 2: IF head == NULL
           SET head = newNode
           Exit
        [END OF IF]
Step 3: Create a temp pointer and traverse to the last node: SET temp = head.
Step 4: WHILE temp->link != NULL
           SET temp = temp->link
        [END OF WHILE]
Step 5: SET temp->link = newNode     // Old last node's 'next' points to new node
Step 6: SET newNode->prev = temp     // New node's 'prev' points back to old last node
```
**Detailed Explanation:**
*   **`Step 3 & 4`**: Traverse the list to find the last node. The loop stops when `temp` is the last node (its `link` is `NULL`).
*   **`Step 5: SET temp->link = newNode`**: The `link` of the old last node is updated from `NULL` to point to the `newNode`, attaching it at the end.
*   **`Step 6: SET newNode->prev = temp`**: The `prev` pointer of the `newNode` is set to point back to the old last node (`temp`), establishing the backward connection.

### 5. Deletion Operation

One of the main benefits of a DLL is easier deletion when you have a pointer to the node you want to delete.

**Algorithm for `deleteNode(nodeToDelete)`:**
```
Step 1: IF head == NULL OR nodeToDelete == NULL, Exit.
Step 2: // If the node to be deleted is the head node
        IF head == nodeToDelete
           SET head = nodeToDelete->link
        [END OF IF]
Step 3: // Change next only if node to be deleted is NOT the last node
        IF nodeToDelete->link != NULL
           SET nodeToDelete->link->prev = nodeToDelete->prev
        [END OF IF]
Step 4: // Change prev only if node to be deleted is NOT the first node
        IF nodeToDelete->prev != NULL
           SET nodeToDelete->prev->link = nodeToDelete->link
        [END OF IF]
Step 5: free(nodeToDelete)
```
**Detailed Explanation:**
*   **`Step 1 & 2`**: Basic checks and handling the edge case where the head node itself is being deleted. If so, we just move `head` to the next node.
*   **`Step 3: nodeToDelete->link->prev = nodeToDelete->prev`**:
    *   **Purpose:** This step "bypasses" the node being deleted from the perspective of the *next* node.
    *   **Why?** `nodeToDelete->link` is the node *after* the one we're deleting. Its `prev` pointer needs to stop pointing to `nodeToDelete` and instead point to the node *before* it, which is `nodeToDelete->prev`. We must check if `nodeToDelete->link` is not `NULL` to avoid an error if we are deleting the last node.
*   **`Step 4: nodeToDelete->prev->link = nodeToDelete->link`**:
    *   **Purpose:** This step "bypasses" the node being deleted from the perspective of the *previous* node.
    *   **Why?** `nodeToDelete->prev` is the node *before* the one we're deleting. Its `link` pointer needs to stop pointing to `nodeToDelete` and instead point to the node *after* it, which is `nodeToDelete->link`. We must check if `nodeToDelete->prev` is not `NULL` to avoid an error if we are deleting the first node.
*   **`Step 5: free(nodeToDelete)`**: The memory for the now-unlinked node is released.

---

### Questions

1.  Differentiate between a singly linked list and a doubly linked list.
2.  What is the main advantage of a doubly linked list when it comes to deleting a node?
3.  Write the algorithm to insert a node at the beginning of a doubly linked list. Explain the pointer adjustments involved.
4.  Why does a doubly linked list require more memory per node compared to a singly linked list?

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

| Feature             | Singly Linked List (SLL)                                  | Doubly Linked List (DLL)                                |
| :------------------ | :-------------------------------------------------------- | :------------------------------------------------------ |
| **Pointers per Node** | One (`next` or `link`).                                   | Two (`next`/`link` and `prev`).                           |
| **Traversal**       | Can only be traversed in the forward direction.           | Can be traversed in both forward and backward directions. |
| **Memory Usage**    | Lower memory overhead per node (only one pointer).        | Higher memory overhead per node (two pointers).         |
| **Deletion**        | Deleting a specific node requires traversing to find its predecessor (O(n)). | Deleting a specific node is more efficient (O(1)) if you have a pointer to that node, as the predecessor is directly accessible via the `prev` pointer. |

---

#### Answer to Question 2

The main advantage of a doubly linked list when deleting a node is **efficiency**. If you have a pointer to the specific node you want to delete, the operation can be completed in **O(1) time**.

This is because the node itself contains a `prev` pointer, giving you direct access to the preceding node. You can then update the `link` of the previous node and the `prev` of the next node without having to traverse the list from the beginning to find the predecessor. In a singly linked list, this same operation would require an O(n) traversal to find the node *before* the one you want to delete.

---

#### Answer to Question 3

**Algorithm to insert at the beginning:**
```
1. Create a new node, `newNode`, with the given value.
2. Check if the list is empty (if `head` is `NULL`). If it is, set `head = newNode` and finish.
3. Set the `link` of `newNode` to point to the current head: `newNode->link = head`.
4. Set the `prev` of the current head to point back to the new node: `head->prev = newNode`.
5. Update the list's `head` to be the `newNode`: `head = newNode`.
```
**Pointer Adjustments Explanation:**
There are three key pointer updates for a non-empty list:
1.  **`newNode->link = head`**: This connects the new node to the front of the existing list, making the old head the second node.
2.  **`head->prev = newNode`**: This is the backward link. The old head node, which is now the second node, must point its `prev` pointer back to the `newNode`.
3.  **`head = newNode`**: The main `head` pointer for the entire list is updated to reference the `newNode`, officially making it the new first node.

---

#### Answer to Question 4

A doubly linked list requires more memory per node because each node must store **two pointers** instead of one.
*   A singly linked list node stores: `[data | next_pointer]`
*   A doubly linked list node stores: `[prev_pointer | data | next_pointer]`

This extra `prev` pointer adds to the size of each node. While this increases the total memory footprint of the list, it provides the benefit of bidirectional traversal and more efficient deletion operations.

</details>
