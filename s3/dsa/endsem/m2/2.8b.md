# Module 2: Arrays and Linked List

## 2.7.b Queues using Linked List

### 1. Advantages of a Linked List for a Queue

Similar to stacks, implementing a queue with a linked list overcomes the primary limitation of array-based implementations (both linear and circular): **fixed size**. A linked list is a dynamic data structure, meaning a queue built upon it can grow as large as the system's memory allows, effectively eliminating the "overflow" condition.

### 2. How it Works

To implement an efficient queue, we need to perform insertions at one end and deletions from the other, both in **O(1)** time.
*   Deletion from the **beginning (head)** of a linked list is O(1).
*   Insertion at the **end (tail)** of a linked list is only O(1) if we maintain a direct pointer to the last node.

Therefore, the standard implementation uses **two pointers**:
1.  **`front`:** Points to the head of the list. This is where `dequeue` operations will happen.
2.  **`rear`:** Points to the tail (last node) of the list. This is where `enqueue` operations will happen.

[Click here for an animation of a Queue implemented with a Linked List](https://www.google.com/search?tbm=isch&q=queue+using+linked+list+front+rear+animation)
**What to look for:** A diagram with `front` and `rear` pointers. Watch how `enqueue` adds a node at the `rear` and updates the `rear` pointer. Watch how `dequeue` removes a node from the `front` and updates the `front` pointer.

### 3. Algorithm for `enqueue(value)`

This algorithm adds a new element to the rear of the queue.

**Pseudocode:**
```
Step 1: Create a new node: SET newNode = createNode(value).
Step 2: IF newNode == NULL, PRINT "Heap Overflow" and Exit.
Step 3: IF rear == NULL (queue is empty)
           SET front = newNode
           SET rear = newNode
        ELSE
           SET rear->link = newNode
           SET rear = newNode
        [END OF IF]
```
**Detailed Line-by-Line Explanation:**

*   **`Step 1 & 2`**: Dynamically allocate memory for the new node. Check if `malloc` was successful. If not, the system is out of memory ("Heap Overflow").
*   **`Step 3: IF rear == NULL`**:
    *   **Purpose:** To handle the special case of adding the **first element** to an empty queue.
    *   **Why?** In an empty queue, both `front` and `rear` are `NULL`. When the first node is added, it is both the first and the last element, so both `front` and `rear` must point to this new node.
*   **`Step 3 (ELSE)`**:
    *   **`SET rear->link = newNode`**:
        *   **Purpose:** To attach the new node to the end of the existing list.
        *   **Why?** The `rear` pointer is currently pointing to the last node in the queue. We need to update this last node's `link` (which is `NULL`) to point to our `newNode`.
    *   **`SET rear = newNode`**:
        *   **Purpose:** To update the `rear` pointer to reflect the new end of the queue.
        *   **Why?** After linking it, the `newNode` is now the last element in the queue, so we must update the `rear` pointer to hold its address.

### 4. Algorithm for `dequeue()`

This algorithm removes and returns the element from the front of the queue.

**Pseudocode:**
```
Step 1: IF front == NULL, PRINT "Queue Underflow" and Exit.
Step 2: Create a temporary pointer: SET temp = front.
Step 3: Get the value to return: SET value = temp->data.
Step 4: Move the front pointer to the next node: SET front = front->link.
Step 5: IF front == NULL
           SET rear = NULL
        [END OF IF]
Step 6: Free the old front node: free(temp).
Step 7: RETURN value.
```
**Detailed Line-by-Line Explanation:**
*   **`Step 1: IF front == NULL`**:
    *   **Purpose:** The **underflow check**.
    *   **Why?** If `front` is `NULL`, it means the queue is empty and there's nothing to remove.
*   **`Step 2 & 3`**: Save the current `front` node in `temp` to prevent a memory leak and retrieve its data before deletion.
*   **`Step 4: SET front = front->link`**:
    *   **Purpose:** The logical "removal" of the front element.
    *   **Why?** We update the `front` pointer to point to the second node in the list, which now becomes the new front.
*   **`Step 5: IF front == NULL`**:
    *   **Purpose:** To handle the edge case where the **last element was just dequeued**.
    *   **Why?** After moving `front` to `front->link`, if `front` becomes `NULL`, it means the node we just dequeued was the only one in the list. In this situation, the queue is now empty. The `rear` pointer would still be pointing to the old (now freed) node, which is a **dangling pointer**. We must also set `rear` to `NULL` to correctly represent the empty state of the queue.
*   **`Step 6 & 7`**: Free the memory of the old front node and return its value.

---

### Questions

1.  Explain how a queue is implemented using a linked list. What is the role of the `front` and `rear` pointers?
2.  What is the time complexity of the `enqueue` and `dequeue` operations for a queue implemented with a linked list, and why?
3.  During a `dequeue` operation, why is it important to check if `front` has become `NULL` and then update the `rear` pointer accordingly?
4.  Compare the advantages of implementing a queue using a linked list versus a circular array.

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

A queue is implemented using a singly linked list by maintaining two pointers: `front` and `rear`.
*   **`front`**: This pointer always points to the **first node (head)** of the linked list. This is the end from which elements are removed (`dequeue`).
*   **`rear`**: This pointer always points to the **last node (tail)** of the linked list. This is the end to which new elements are added (`enqueue`).

When a new element is enqueued, a new node is created and added *after* the current `rear` node, and the `rear` pointer is updated to this new node. When an element is dequeued, the node pointed to by `front` is removed, and the `front` pointer is updated to the next node in the list. This two-pointer design ensures that both operations are highly efficient.

---

#### Answer to Question 2

For a queue implemented with a linked list using `front` and `rear` pointers, the time complexities are:
*   **`enqueue` is O(1):** Adding an element to the rear involves a few fixed steps: create a new node, set the `link` of the current `rear` node to the new node, and then update the `rear` pointer. The time taken does not depend on the number of elements already in the queue.
*   **`dequeue` is O(1):** Removing an element from the front involves: saving the `front` node, updating the `front` pointer to the next node, and freeing the old node's memory. This is also a fixed number of steps, independent of the queue's size.

This O(1) performance for both core operations is the primary reason this implementation is so effective.

---

#### Answer to Question 3

It is a critical edge case to check if `front` has become `NULL` after a dequeue operation. This situation occurs when we are removing the **last and only element** from the queue.

**Reasoning:**
1.  Before the `dequeue`, both `front` and `rear` point to the same single node.
2.  During `dequeue`, we update `front` to `front->link`. Since this was the last node, its `link` is `NULL`, so `front` becomes `NULL`.
3.  At this point, the queue is logically empty. However, the `rear` pointer still holds the address of the node that was just freed. This is called a **dangling pointer** and can lead to bugs if another operation tries to use it.
4.  By explicitly checking `if (front == NULL)`, we can detect that the queue is now empty and set `rear = NULL` as well. This ensures that both pointers correctly reflect the empty state of the queue.

---

#### Answer to Question 4

Both a linked list and a circular array provide efficient O(1) implementations for queue operations. The main differences lie in memory management and size limitations.

| Feature               | Linked List Implementation                                       | Circular Array Implementation                               |
| :-------------------- | :--------------------------------------------------------------- | :---------------------------------------------------------- |
| **Size**              | **Dynamic.** Can grow to any size, limited only by system memory. | **Fixed.** The maximum size must be defined at compile time. |
| **Overflow**          | Only occurs if the system runs out of memory (Heap Overflow).    | Occurs when the array is full.                              |
| **Memory Usage**      | Uses memory only for the elements it currently holds, but has **pointer overhead** for each node. | May waste memory if the array is allocated large but only holds a few elements. No pointer overhead. |
| **Memory Locality**   | Poor. Nodes can be scattered across memory, which can be slower due to CPU cache misses. | Excellent. Elements are stored in contiguous memory, which is cache-friendly and generally faster. |

**Conclusion:** A **linked list** is better when the maximum size of the queue is unknown or varies widely. A **circular array** is generally faster and more memory-efficient (due to no pointer overhead and better cache performance) if you can confidently predict a reasonable maximum size for the queue.

</details>
