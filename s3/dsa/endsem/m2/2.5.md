# Module 2: Arrays and Linked List

## 2.4 Linked List: Introduction, Self-Referential Structures, and Dynamic Memory Allocation

This section introduces the **Linked List**, a powerful and flexible alternative to the array for storing linear data. We will cover the fundamental concepts that make linked lists possible: self-referential structures and dynamic memory allocation.

### 1. Introduction to Linked Lists

A **Linked List** is a linear data structure where elements are not stored in contiguous memory locations. Instead, each element, called a **Node**, consists of two parts:
1.  **Data:** The actual value or data item being stored.
2.  **Link (or Pointer):** An address that points to the next node in the sequence.

The list is accessed via a starting pointer, often called `start` or `head`, which points to the first node. The last node in the list has a link that points to `NULL`, indicating the end of the sequence.

[Click here for a diagram of a simple Linked List](https://www.google.com/search?tbm=isch&q=singly+linked+list+diagram+head+node+null)
**What to look for:** A series of boxes (nodes) connected by arrows. The first node is pointed to by `head`. Each node contains a `data` part and a `link` part (the arrow). The arrow from the last node points to `NULL`.

#### Advantages of Linked Lists Over Arrays
*   **Dynamic Size:** Linked lists can grow and shrink during program execution. You don't need to specify their size at compile time, which avoids wasted memory or overflow errors.
*   **Ease of Insertion and Deletion:** Inserting or deleting an element in the middle of a linked list is very efficient. You only need to update a few pointers, which is a constant time `O(1)` operation (if the node's location is known). In an array, the same operations require shifting all subsequent elements, which is a slow `O(n)` operation.

#### Disadvantages of Linked Lists
*   **No Random Access:** You cannot directly access an element by its index (like `arr[5]`). To reach the i-th element, you must traverse the list from the `head`, which takes `O(n)` time.
*   **Extra Memory Overhead:** Each node in a linked list requires extra memory to store the pointer (link), which is not required in an array.

### 2. Self-Referential Structures

The magic behind linked lists lies in a C programming concept called a **self-referential structure**. This is a structure that contains a member which is a **pointer to another structure of the same type**.

This ability to "point to itself" is what allows us to create a chain of nodes. Each node can hold the memory address of the next node, linking them together.

**Defining a Node in C:**
This is the fundamental building block of a linked list.

```c
// Define the Node structure
struct Node {
    int data; // The data part of the node
    struct Node* link; // The pointer part. It points to another Node.
};
```
*   `int data;`: This member stores the actual value of the node.
*   `struct Node* link;`: This is the self-referential part. `link` is a pointer of type `struct Node*`, meaning it is designed to hold the memory address of another `struct Node`.

### 3. Dynamic Memory Allocation

Arrays are a form of **static memory allocation**; their size is fixed when the program is compiled. Because a linked list needs to grow and shrink on demand, we must use **dynamic memory allocation**, where memory is requested from the operating system at runtime.

In C, this is primarily done using the `malloc()` function.

#### The `malloc()` Function
*   **Purpose:** `malloc` stands for "memory allocation". It is a standard library function (`<stdlib.h>`) that reserves a block of memory of a specified size from a memory area called the **heap**.
*   **Syntax:** `void* malloc(size_t size);`
*   **Return Value:** It returns a `void` pointer to the beginning of the allocated block. A `void` pointer is a generic pointer that can be cast to any other pointer type. If `malloc` fails to allocate memory (e.g., if the system is out of memory), it returns `NULL`.

**How to Use `malloc` to Create a Node:**
This is the standard procedure for adding a new node to a linked list.
```c
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data;
    struct Node* link;
};

// Function to create a new node
struct Node* createNode(int value) {
    // 1. Allocate memory for one 'struct Node'
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));

    // 2. Check if allocation was successful
    if (newNode == NULL) {
        printf("Memory allocation failed!\n");
        exit(1); // Exit the program if memory is full
    }

    // 3. Initialize the new node
    newNode->data = value;
    newNode->link = NULL;

    // 4. Return the pointer to the newly created node
    return newNode;
}
```
**Explanation:**
1.  `sizeof(struct Node)` calculates the number of bytes required to store one node.
2.  `malloc()` requests that many bytes from the heap.
3.  `(struct Node*)` is a **type cast**. It converts the generic `void*` returned by `malloc` into a `struct Node*` pointer, so we can access its members (`data` and `link`).
4.  It's crucial to check for `NULL` to handle potential memory allocation failures gracefully.

#### The `free()` Function
When a node is deleted from a linked list, the memory it occupied must be returned to the system to be reused. The `free(pointer)` function does this, preventing **memory leaks**.

---

### Questions

1.  What are self-referential structures? Explain with a C code example how they are used to build a linked list. (From *Question Bank*)
2.  Explain the concept of dynamic memory allocation in C. Why is it essential for linked lists? (From *Question Bank*)
3.  List three main advantages of a linked list over an array.
4.  What is the purpose of the `malloc()` function? Show how it's used to create a node for a linked list and explain the role of `sizeof` and type casting in that statement.

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

A **self-referential structure** is a structure that includes a member that is a pointer to another structure of the same type. This feature is the fundamental principle that allows data structures like linked lists and trees to be created, as it enables one instance of the structure to be linked to another.

**C Code Example:**
The `struct Node` is the classic example of a self-referential structure used in a linked list:
```c
struct Node {
    int data;           // A data member to store a value
    struct Node* next;  // A pointer member that points to another 'struct Node'
};
```
**How it is used:**
The `next` pointer in each `struct Node` instance stores the memory address of the subsequent node in the list. This creates a chain of nodes. The `next` pointer of the last node is set to `NULL` to signify the end of the list. A separate `head` pointer is used to store the address of the very first node, providing an entry point to the list.

---

#### Answer to Question 2

**Dynamic memory allocation** is the process of allocating memory for variables and data structures at **runtime** rather than at compile time. In C, this is done using functions like `malloc()`, `calloc()`, and `realloc()`, which reserve memory from a part of the system's memory called the **heap**. The memory remains allocated until it is explicitly released by the programmer using `free()`.

**Why it is essential for linked lists:**
Linked lists are, by definition, dynamic data structures. Their primary advantage over arrays is the ability to grow and shrink on demand as the program runs.
*   **Growth:** When a new element is added to a linked list, a new node must be created. Dynamic memory allocation (`malloc`) is essential to request memory for this new node from the system at that moment.
*   **Shrinking:** When an element is deleted, the memory occupied by its node can be returned to the system using `free()`, making that memory available for other uses.

Without dynamic memory allocation, you would have to pre-allocate a fixed-size array of nodes, which would defeat the purpose of a linked list and reintroduce the limitations of a standard array (fixed size, wasted memory).

---

#### Answer to Question 3

Three main advantages of a linked list over an array are:
1.  **Dynamic Size:** Linked lists can expand and contract as needed at runtime, whereas the size of an array is fixed at compile time.
2.  **Efficient Insertion/Deletion:** Inserting or deleting an element in the middle of a linked list is a fast `O(1)` operation (if the location is known), as it only requires updating a few pointers. In an array, this is a slow `O(n)` operation because it requires shifting all subsequent elements.
3.  **No Wasted Memory:** With linked lists, memory is allocated on a per-node basis, so you only use as much memory as you need. With arrays, you often have to allocate a larger size than necessary to accommodate future growth, leading to wasted space.

---

#### Answer to Question 4

The purpose of the `malloc()` function is to **dynamically allocate a block of memory of a specified size from the heap** at runtime.

**Usage for creating a linked list node:**
```c
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
```
**Role of `sizeof` and type casting:**
*   **`sizeof(struct Node)`:** This operator calculates the exact number of bytes required to store a single `struct Node` (including its data and pointer members). This is crucial because it ensures that `malloc` allocates precisely the right amount of memory for one node, making the code portable across different systems where the size of data types might vary.
*   **`(struct Node*)`:** This is a **type cast**. The `malloc()` function returns a generic `void*` pointer (a pointer to an unspecified type). The type cast converts this generic pointer into a specific pointer of type `struct Node*`. This is necessary so that the C compiler knows how to interpret the block of memory and allows you to access its members using the `->` operator (e.g., `newNode->data`).

</details>
