# Module 2: Arrays and Linked List

## 2.5 Singly Linked List Operations

A **Singly Linked List** is the most basic type of linked list. Each node contains data and a single pointer (`link` or `next`) that points to the next node in the sequence. This section covers the fundamental operations performed on a singly linked list, such as traversal, insertion, and deletion.

### 1. Traversing a Linked List

Traversal means visiting every node in the list exactly once, starting from the first node (`head`). This is the basis for many other operations like displaying, searching, and counting.

**Algorithm for Traversal:**
```
Step 1: IF head == NULL, PRINT "List is empty" and Exit.
Step 2: Create a temporary pointer, temp, and initialize it with head. (temp = head)
Step 3: WHILE temp != NULL:
           a. Process the data of the current node (e.g., print temp->data).
           b. Move to the next node: SET temp = temp->link.
        [END OF WHILE]
```
**Explanation:**
We use a temporary pointer `temp` so we don't lose the reference to the `head` of the list. The loop continues as long as `temp` is not `NULL`. In each iteration, we process the current node's data and then advance `temp` to the next node by following its `link`. The loop terminates when `temp` becomes `NULL`, which happens after it has passed the last node.

### 2. Insertion Operations

Insertion involves adding a new node to the list. There are three primary cases:

#### a) Insertion at the Beginning

This is the most efficient insertion operation in a singly linked list.

[Click here for an animation of Insertion at the Beginning](https://www.google.com/search?tbm=isch&q=singly+linked+list+insert+at+beginning+animation)
**What to look for:** A new node is created. Its `link` is made to point to the current `head` node. Then, the `head` pointer is updated to point to this new node, making it the new first node.

**Algorithm for `insertAtFirst(value)`:**
```
Step 1: Create a new node: SET newNode = createNode(value).
Step 2: Set the link of the new node to point to the current head: SET newNode->link = head.
Step 3: Update the head to point to the new node: SET head = newNode.
```
**Detailed Explanation:**
*   **`Step 1`**: A new node is created in memory using `malloc`, and its data field is set to `value`.
*   **`Step 2`**: This is the crucial step. We make the `link` of our `newNode` point to whatever `head` was pointing to. This connects our new node to the rest of the list. If the list was empty (`head` was `NULL`), then `newNode->link` correctly becomes `NULL`.
*   **`Step 3`**: The `head` pointer of the list is updated to point to our `newNode`, officially making it the new first element of the list. This is an **O(1)** operation.

#### b) Insertion at the End

To insert a node at the end, we must first traverse the list to find the last node.

**Algorithm for `insertAtEnd(value)`:**
```
Step 1: Create a new node: SET newNode = createNode(value).
Step 2: IF head == NULL (list is empty):
           SET head = newNode
           Exit
        [END OF IF]
Step 3: Create a temporary pointer, temp, and initialize it with head.
Step 4: WHILE temp->link != NULL:
           SET temp = temp->link
        [END OF WHILE]
Step 5: Link the last node to the new node: SET temp->link = newNode.
```
**Detailed Explanation:**
*   **`Step 2`**: Handles the edge case where the list is empty. If so, the new node becomes the `head`.
*   **`Step 4`**: This `while` loop traverses the list. `temp` keeps moving to the next node until `temp->link` is `NULL`. When the loop terminates, `temp` will be pointing to the **last node** of the list.
*   **`Step 5`**: The `link` of the last node (which was `NULL`) is updated to point to the `newNode`, thereby attaching it to the end of the list. This is an **O(n)** operation because of the traversal.

#### c) Insertion at a Specific Position

This involves traversing to the node just before the desired insertion point.

**Algorithm for `insertAtPosition(value, position)`:**
```
Step 1: IF position == 0, call insertAtFirst(value) and Exit.
Step 2: Create a new node: SET newNode = createNode(value).
Step 3: Create a temporary pointer, temp, and initialize it with head.
Step 4: FOR i = 0 TO position-2:
           IF temp == NULL, PRINT "Position out of range" and Exit.
           SET temp = temp->link
        [END OF FOR]
Step 5: SET newNode->link = temp->link
Step 6: SET temp->link = newNode
```
**Detailed Explanation:**
*   **`Step 4`**: This loop traverses the list to find the node **just before** the target position. We loop `position-1` times. For example, to insert at position 3, we need to stop at the node at position 2.
*   **`Step 5`**: The `link` of the `newNode` is set to point to the node that was originally after `temp`. This ensures we don't lose the rest of the list.
*   **`Step 6`**: The `link` of `temp` (the node before the insertion point) is updated to point to our `newNode`. This "splices" the new node into the list.

### 3. Deletion Operations

Deletion involves removing a node and freeing its memory.

#### a) Deletion from the Beginning

**Algorithm for `deleteFromFirst()`:**
```
Step 1: IF head == NULL, PRINT "List is empty" and Exit.
Step 2: Create a temporary pointer, temp, to hold the current head: SET temp = head.
Step 3: Move the head to the next node: SET head = head->link.
Step 4: Free the memory of the old head: free(temp).
```
**Detailed Explanation:**
*   **`Step 2`**: We must save the address of the first node in `temp` before we change `head`. If we don't, we will lose the reference to that memory block and won't be able to free it (a memory leak).
*   **`Step 3`**: `head` is updated to point to the second node, which now becomes the new first node of the list.
*   **`Step 4`**: The memory occupied by the original first node is returned to the system. This is an **O(1)** operation.

#### b) Deletion from the End

This is the least efficient operation in a singly linked list, as we need to find the **second-to-last** node.

**Algorithm for `deleteFromEnd()`:**
```
Step 1: IF head == NULL, PRINT "List is empty" and Exit.
Step 2: Create a temporary pointer, temp, and initialize it with head.
Step 3: IF temp->link == NULL (only one node):
           free(head)
           SET head = NULL
           Exit
        [END OF IF]
Step 4: WHILE temp->link->link != NULL:
           SET temp = temp->link
        [END OF WHILE]
Step 5: Create a pointer to the last node: SET nodeToDelete = temp->link.
Step 6: Set the link of the second-to-last node to NULL: SET temp->link = NULL.
Step 7: Free the last node: free(nodeToDelete).
```
**Detailed Explanation:**
*   **`Step 3`**: Handles the edge case where there is only one node in the list.
*   **`Step 4`**: This is the key traversal. The loop condition `temp->link->link != NULL` makes the loop stop when `temp` is pointing to the **second-to-last** node. We need this node because we must update its `link` to `NULL`.
*   **`Step 6 & 7`**: The `link` of the new last node is set to `NULL`, and the old last node is freed. This is an **O(n)** operation due to the traversal.

---

### Questions

1.  Write algorithms for insertion and deletion of a node in a singly linked list. (Cover insertion at beginning and deletion from end).
2.  Explain why inserting a node at the beginning of a singly linked list is an O(1) operation, while deleting a node from the end is an O(n) operation.
3.  What is a `NULL` pointer, and what is its significance in a linked list?
4.  Write the C `struct` definition for a node in a singly linked list. Explain what a self-referential structure is in this context.

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

**Algorithm for Insertion at the Beginning:**
1.  Allocate memory for a new node (`newNode`).
2.  Set the data for `newNode`.
3.  Make the `link` of the `newNode` point to the current `head` of the list (`newNode->link = head`).
4.  Update the `head` pointer to point to the `newNode` (`head = newNode`).

**Algorithm for Deletion from the End:**
1.  Check if the list is empty (`head == NULL`). If so, report an error.
2.  If the list has only one node (`head->link == NULL`), free the `head` and set `head` to `NULL`.
3.  Traverse the list with a temporary pointer `temp` until it points to the **second-to-last** node. The condition for this is `temp->link->link != NULL`.
4.  Store the address of the last node (`temp->link`) in another pointer `nodeToDelete`.
5.  Set the `link` of the second-to-last node to `NULL` (`temp->link = NULL`).
6.  Free the memory of the last node (`free(nodeToDelete)`).

---

#### Answer to Question 2

*   **Insertion at the Beginning (O(1)):** This operation is constant time because it does not depend on the number of elements (`n`) in the list. It only involves a fixed number of pointer reassignments: create a new node, point its `link` to the current `head`, and then update `head` to point to the new node. These steps take the same amount of time whether the list has 0 or 1 million nodes.

*   **Deletion from the End (O(n)):** This operation is linear time because, in a singly linked list, we can only move forward. To delete the last node, we must first find the **second-to-last** node to update its `link` pointer to `NULL`. There is no direct way to access this node, so we must traverse the entire list from the `head` until we find it. This traversal takes a number of steps proportional to the length of the list, `n`.

---

#### Answer to Question 3

A **`NULL` pointer** is a special pointer that does not point to any valid memory address. In C, it is a macro defined as `(void*)0`.

**Significance in a Linked List:**
The `NULL` pointer plays a critical role as a **terminator**. The `link` part of the **last node** in a linked list is always set to `NULL`. This serves as a clear signal that the end of the list has been reached. This is essential for traversal operations (like displaying or searching), as the loop knows to stop when it encounters a `NULL` link. It also helps in identifying a list with a single node (where `head->link` is `NULL`) or an empty list (where `head` itself is `NULL`).

---

#### Answer to Question 4

**C `struct` definition for a node:**
```c
struct Node {
    int data;           // Member to store the data value
    struct Node* link;  // Member that is a pointer to the next node
};
```
**Self-Referential Structure in this context:**
The `struct Node` is a **self-referential structure** because one of its members, `link`, is a pointer to a structure of its own type (`struct Node*`). This "self-reference" is what makes a linked list possible. It allows an instance of a `Node` to hold the memory address of another `Node`, creating a chain-like structure where each node is linked to the next.

</details>
