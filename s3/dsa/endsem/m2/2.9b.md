# Module 2: Arrays and Linked List

## 2.8.b Polynomial Representation

A key application of linear data structures is the representation and manipulation of mathematical polynomials. A polynomial is an expression consisting of variables and coefficients, such as `5x³ + 4x² + 2`.

The main challenge is storing these efficiently, especially **sparse polynomials** where many terms have zero coefficients (e.g., `x¹⁰⁰ + 1`).

### 1. Polynomial Representation using Arrays

A simple approach is to use an array where the index of the array represents the exponent of a term, and the value at that index represents its coefficient.

*   **Example:** For `5x³ + 4x² + 2`, an array `coeff` could be `[2, 0, 4, 5]`. Here `coeff[3]` is 5, `coeff[2]` is 4, etc.
*   **Disadvantage:** This is extremely wasteful for sparse polynomials. To represent `x¹⁰⁰ + 1`, you would need an array of size 101, with 99 of its elements being zero. The size of the array depends on the highest degree, not the number of terms.

A better array-based approach is to use an array of structs or a 2D array to store `(coefficient, exponent)` pairs for non-zero terms. However, this still has the fixed-size limitation of arrays.

### 2. Polynomial Representation using Linked Lists

A linked list is the most flexible and common way to represent polynomials, especially sparse ones. Each **node** in the linked list represents a single **term** of the polynomial.

**Node Structure in C:**
```c
struct Node {
    int coef;          // The coefficient of the term
    int exp;           // The exponent of the term
    struct Node* link; // Pointer to the next term
};
```
*   A polynomial is represented by a linked list of these nodes.
*   The list is typically kept **sorted in descending order of exponents**. This makes operations like addition much more efficient.

[Click here for a diagram of Polynomial Representation using a Linked List](https://www.google.com/search?tbm=isch&q=polynomial+representation+using+linked+list)
**What to look for:** A diagram showing a polynomial like `5x³ + 4x² + 2`. It should be represented as a chain of three nodes. The first node contains `(5, 3)`, the second `(4, 2)`, and the third `(2, 0)`.

### 3. Algorithm: Polynomial Addition using Linked Lists

This algorithm adds two polynomials (`poly1` and `poly2`) represented as linked lists (sorted by exponent) and creates a new linked list (`result`) for their sum.

**Pseudocode:**
```
1. Initialize result list as empty.
2. WHILE poly1 is not NULL AND poly2 is not NULL:
    a. IF poly1->exp > poly2->exp:
          Add the term from poly1 to the result list.
          Move to the next term in poly1.
    b. ELSE IF poly2->exp > poly1->exp:
          Add the term from poly2 to the result list.
          Move to the next term in poly2.
    c. ELSE (exponents are equal):
          Calculate sum of coefficients: sum_coef = poly1->coef + poly2->coef.
          IF sum_coef != 0:
             Add a new term (sum_coef, poly1->exp) to the result list.
          Move to the next term in both poly1 and poly2.
3. WHILE poly1 is not NULL:
      Add the remaining term from poly1 to the result list.
      Move to the next term in poly1.
4. WHILE poly2 is not NULL:
      Add the remaining term from poly2 to the result list.
      Move to the next term in poly2.
5. RETURN result.
```
**Explanation of the Logic:**
The algorithm works like a "merge" operation. By traversing both lists simultaneously, we can compare terms.
*   If one term has a higher exponent, it doesn't have a matching term in the other polynomial, so it's added directly to the result.
*   If the exponents match, we add the coefficients and create a single new term for the result. We only add the term if the resulting coefficient is non-zero.
*   Finally, once one of the lists is fully traversed, the remaining terms from the other list are simply appended to the end of the result.

### 4. Algorithm: Polynomial Multiplication using Linked Lists

Multiplying two polynomials involves multiplying each term of the first polynomial by every term of the second polynomial.

**Pseudocode:**
```
1. Initialize a result list as empty.
2. FOR each term `p1` in `poly1`:
    a. FOR each term `p2` in `poly2`:
        i.   Calculate new coefficient: new_coef = p1->coef * p2->coef.
        ii.  Calculate new exponent: new_exp = p1->exp + p2->exp.
        iii. Insert a new term (new_coef, new_exp) into the result list.
             (The insertion function for the result list must handle adding coefficients if a term with new_exp already exists).
3. RETURN result.
```
**Explanation of the Logic:**
This is a nested loop approach. The outer loop iterates through `poly1`, and the inner loop iterates through `poly2`. For every combination of terms, a new term is generated. The key is the insertion step into the `result` list. The function used to add terms to `result` must be "smart" – if a term with a given exponent already exists, it should add the new coefficient to the existing one instead of creating a duplicate node.

---

### Questions

1.  How can a linked list be used to represent the polynomial `5x⁴ + 2x³ - 17x + 45`? Write the C `struct` for the node and draw the linked list.
2.  Write an algorithm to add two polynomials represented using linked lists.
3.  How would you represent a bivariate polynomial (a polynomial with two variables, e.g., `5x⁴y⁶ + 24x³y⁴`) using a linked list? Describe the node structure.
4.  Why is a linked list generally a better choice than an array for representing sparse polynomials?

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

A linked list can represent the polynomial by having each node store the coefficient and exponent of a non-zero term. The list is kept sorted by exponent in descending order.

**C `struct` for the node:**
```c
struct Node {
    int coef;          // Coefficient
    int exp;           // Exponent
    struct Node* link; // Pointer to the next term
};
```

**Linked List Diagram for `5x⁴ + 2x³ - 17x + 45`:**
The polynomial is `5x⁴ + 2x³ - 17x¹ + 45x⁰`.

`head` -> `[coef:5, exp:4]` -> `[coef:2, exp:3]` -> `[coef:-17, exp:1]` -> `[coef:45, exp:0]` -> `NULL`

Each box represents a node in the linked list.

---

#### Answer to Question 2

**Algorithm for Polynomial Addition:**
This algorithm assumes both input lists (`poly1`, `poly2`) are sorted by exponent in descending order.

1.  Initialize an empty linked list for the `result`.
2.  Use two pointers, `p1` for `poly1` and `p2` for `poly2`.
3.  **WHILE `p1` is not NULL and `p2` is not NULL:**
    *   **IF `p1->exp > p2->exp`:** Create a new node with `p1`'s data and add it to `result`. Advance `p1`.
    *   **ELSE IF `p2->exp > p1->exp`:** Create a new node with `p2`'s data and add it to `result`. Advance `p2`.
    *   **ELSE (`p1->exp == p2->exp`):**
        *   Calculate `sum_coef = p1->coef + p2->coef`.
        *   If `sum_coef` is not 0, create a new node with `(sum_coef, p1->exp)` and add it to `result`.
        *   Advance both `p1` and `p2`.
4.  **Append remaining terms:** After the main loop, if `p1` is not `NULL`, append the rest of `poly1` to `result`. If `p2` is not `NULL`, append the rest of `poly2` to `result`.
5.  Return the `result` list.

---

#### Answer to Question 3

To represent a bivariate polynomial like `5x⁴y⁶ + 24x³y⁴`, the node structure needs to be extended to hold exponents for both variables.

**Node Structure for a Bivariate Polynomial:**
```c
struct Node {
    int coef;        // Coefficient
    int exp_x;       // Exponent for variable x
    int exp_y;       // Exponent for variable y
    struct Node* link; // Pointer to the next term
};
```
Using this structure, the polynomial `5x⁴y⁶ + 24x³y⁴` would be represented as a linked list of two nodes:
`head` -> `[coef:5, exp_x:4, exp_y:6]` -> `[coef:24, exp_x:3, exp_y:4]` -> `NULL`

To keep the list sorted, a consistent rule must be followed, for example, sorting first by `exp_x` in descending order, and then by `exp_y` for terms with the same `exp_x`.

---

#### Answer to Question 4

A linked list is a better choice for **sparse polynomials** (polynomials with many zero-coefficient terms, like `x¹⁰⁰ + 1`) due to **memory efficiency**.

*   **Array Representation:** If you use a simple array where the index represents the exponent, you must allocate an array large enough to hold the highest exponent. For `x¹⁰⁰ + 1`, this would require an array of size 101. Only two elements (`coeffs[100]` and `coeffs[0]`) would be non-zero, while the other 99 would be zero, wasting a significant amount of memory.

*   **Linked List Representation:** A linked list only stores nodes for **non-zero terms**. To represent `x¹⁰⁰ + 1`, you only need two nodes: one for `(coef:1, exp:100)` and one for `(coef:1, exp:0)`. This uses a minimal amount of memory that is proportional to the number of actual terms, not the highest degree of the polynomial.

</details>
