# Module 2: Arrays and Linked List

## 2.6.b Circular Linked List

### 1. What is a Circular Linked List?

A **Circular Linked List** is a variation of a linked list in which the `link` of the last node does not point to `NULL`. Instead, it points back to the **first node** (the `head`) of the list, forming a closed loop or circle.

This structure is useful in applications where you need to cycle through a list repeatedly, such as a round-robin scheduling algorithm in an operating system or a playlist that repeats.

[Click here for a diagram of a Circular Linked List](https://www.google.com/search?tbm=isch&q=circular+linked+list+diagram)
**What to look for:** A chain of nodes connected by arrows, similar to a singly linked list, but with one key difference: the arrow from the **last node** points back to the **first node** instead of pointing to `NULL`.

### 2. Key Differences from a Singly Linked List

*   **Termination:** Traversal does not end by checking for a `NULL` pointer. Instead, you traverse until you reach the `head` node again.
*   **Pointer to Last Node:** It is often more convenient to maintain a pointer to the **last node** (let's call it `tail`) instead of the `head`.
    *   **Why?** If you have a pointer to the `tail`, you can access the `head` in O(1) time via `tail->link`. You also have direct access to the end of the list. This makes both insertion at the beginning and insertion at the end O(1) operations, which is a significant improvement.

### 3. Traversal in a Circular Linked List

Traversing a circular list requires a different termination condition. You must stop when you've circled back to the starting point.

**Algorithm for Traversal (starting from `head`):**
```
Step 1: IF head == NULL, PRINT "List is empty" and Exit.
Step 2: Create a temporary pointer, temp, and initialize it with head.
Step 3: REPEAT
           a. Process the data of the current node (e.g., print temp->data).
           b. Move to the next node: SET temp = temp->link.
        UNTIL temp == head
```
**Detailed Explanation:**
*   **`Step 2: temp = head`**: We initialize a temporary pointer `temp` to start at the beginning of the list.
*   **`Step 3: REPEAT ... UNTIL temp == head`**: This is a `do-while` style loop. We use this structure because we need to process the first node *before* checking the loop condition. If we used a `while (temp != head)` loop, it would terminate immediately without processing any nodes. The loop continues until `temp` has traversed the entire list and points back to the `head` node.

### 4. Insertion Operations

Let's assume we are using a single `start` pointer (which points to the first node) for these algorithms.

#### a) Insertion at the Beginning

**Algorithm for `insertAtFirst(value)`:**
```
Step 1: Create a new node: SET newNode = createNode(value).
Step 2: IF start == NULL (list is empty)
           SET start = newNode
           SET newNode->link = start // Points to itself
           Exit
        [END OF IF]
Step 3: Create a temp pointer and traverse to the last node.
Step 4: WHILE temp->link != start
           SET temp = temp->link
        [END OF WHILE]
Step 5: SET newNode->link = start
Step 6: SET temp->link = newNode
Step 7: SET start = newNode
```
**Detailed Explanation:**
*   **`Step 2`**: If the list is empty, the new node becomes the `start`, and its `link` points to itself to form the circle.
*   **`Step 4`**: This loop traverses the list to find the **last node**. The last node is the one whose `link` points to `start`.
*   **`Step 5 & 6`**: The `newNode`'s link is set to point to the old `start`, and the last node's link is updated to point to the `newNode`. This inserts the `newNode` at the front and maintains the circle.
*   **`Step 7`**: The `start` pointer is updated to point to the `newNode`, making it the new first node.

#### b) Insertion at the End

**Algorithm for `insertAtEnd(value)`:**
```
Step 1: Create a new node: SET newNode = createNode(value).
Step 2: IF start == NULL (list is empty)
           SET start = newNode
           SET newNode->link = start
           Exit
        [END OF IF]
Step 3: Create a temp pointer and traverse to the last node.
Step 4: WHILE temp->link != start
           SET temp = temp->link
        [END OF WHILE]
Step 5: SET temp->link = newNode
Step 6: SET newNode->link = start
```
**Detailed Explanation:**
*   **`Step 4`**: Just like before, this loop finds the last node (`temp`).
*   **`Step 5`**: The `link` of the old last node (`temp`) is updated to point to the `newNode`.
*   **`Step 6`**: The `link` of the `newNode` is set to point to `start`, closing the circle and making the `newNode` the new last element.

### 5. Deletion Operation

#### Deletion from the Beginning

**Algorithm for `deleteFromFirst()`:**
```
Step 1: IF start == NULL, PRINT "List is empty" and Exit.
Step 2: IF start->link == start (only one node)
           free(start)
           SET start = NULL
           Exit
        [END OF IF]
Step 3: Create temp and last pointers, initializing both to start.
Step 4: WHILE last->link != start
           SET last = last->link
        [END OF WHILE]
Step 5: SET temp = start // temp points to the node to be deleted
Step 6: SET start = start->link
Step 7: SET last->link = start
Step 8: free(temp)
```
**Detailed Explanation:**
*   **`Step 2`**: Handles the edge case where there is only one node in the list. After deleting it, the list is empty (`start = NULL`).
*   **`Step 4`**: This loop finds the last node (`last`). We need this node to update its `link` pointer.
*   **`Step 6`**: The `start` pointer is moved to the second node, making it the new beginning of the list.
*   **`Step 7`**: The `link` of the last node is updated to point to the new `start`, closing the circle again.
*   **`Step 8`**: The memory of the original first node is released.

---

### Questions

1.  What is a circular linked list and how does it differ from a standard singly linked list?
2.  What is a common real-world application where a circular linked list would be useful?
3.  Explain why it can be more advantageous to use a pointer to the *last* node (`tail`) rather than the *first* node (`head`) in a circular linked list.
4.  Write the algorithm for traversing and displaying all elements in a circular linked list. Why can't we just check for `NULL` to stop the traversal?

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

A **Circular Linked List** is a linked list where the last node points back to the first node instead of pointing to `NULL`.

**Key Differences:**
1.  **Termination:** A singly linked list terminates with a `NULL` pointer. A circular linked list forms a closed loop, so it has no end in that sense.
2.  **Structure:** The last node of an SLL points to `NULL`. The last node of a CLL points to the `head` node.
3.  **Traversal:** Traversing an SLL stops when a `NULL` pointer is reached. Traversing a CLL requires checking if you have returned to the starting node.
4.  **Infinite Loops:** If not handled carefully, traversal code for a CLL can result in an infinite loop.

---

#### Answer to Question 2

A common real-world application is a **round-robin scheduling algorithm** used in operating systems. In this system, multiple processes are given a small time slice of CPU time in a repeating cycle. A circular linked list is a perfect data structure to manage these processes. The scheduler can traverse the list, give a process its time slice, and then move to the next process in the circle. When it reaches the end, it naturally loops back to the beginning to start the cycle over. Other applications include playlists in media players or managing turns in a multiplayer game.

---

#### Answer to Question 3

Using a pointer to the **last node (`tail`)** is more advantageous because it provides **O(1) time complexity for both insertion at the beginning and insertion at the end**.

*   **Accessing the Head:** If you have the `tail` pointer, the head of the list is simply `tail->link`. This is an O(1) operation.
*   **Accessing the Tail:** You already have the `tail` pointer. This is an O(1) operation.

**Operations:**
*   **Insertion at End:** Create a new node, set `newNode->link = tail->link` (the old head), and then `tail->link = newNode`. Finally, update `tail = newNode`. All are O(1) steps.
*   **Insertion at Beginning:** This is almost the same as insertion at the end, but you don't update the `tail` pointer.

If you only store a `head` pointer, insertion at the end would require an O(n) traversal to find the last node. Using a `tail` pointer gives you the best of both worlds.

---

#### Answer to Question 4

**Algorithm for Traversal:**
```
1. IF head == NULL, PRINT "List is empty" and Exit.
2. Create a temporary pointer, `temp`, and set it to `head`.
3. Use a do-while loop:
   DO
     a. Print `temp->data`.
     b. Move to the next node: `temp = temp->link`.
   WHILE (`temp != head`)
```
**Why we can't check for `NULL`:**
In a circular linked list, **no node's link is ever `NULL`** (unless the list is empty). The last node's link points back to the `head`. If you were to traverse the list with a condition like `while (temp != NULL)`, the condition would never be met, and the loop would run foreverâ€”an infinite loop. Therefore, the correct termination condition is to check if the traversal pointer has returned to the starting node (`head`).

</details>
