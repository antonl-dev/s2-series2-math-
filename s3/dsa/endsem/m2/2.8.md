# Module 2: Arrays and Linked List

## 2.7.a Stacks using Linked List

### 1. Why Use a Linked List for a Stack?

While an array is a simple way to implement a stack, it has one major limitation: **fixed size**. When the array is full, no more elements can be pushed, leading to an "overflow" condition.

Implementing a stack using a **linked list** solves this problem entirely. A linked list is a dynamic data structure that can grow and shrink as needed at runtime. This means a linked-list-based stack can never truly be "full" unless the system runs out of memory. This is a significant advantage mentioned in your exam paper (Question 4, "Discuss the advantages...").

### 2. How it Works

To implement a stack using a linked list, we treat the **head of the list as the top of the stack**.
*   The `push` operation is equivalent to **inserting a node at the beginning** of the list.
*   The `pop` operation is equivalent to **deleting the node from the beginning** of the list.

This design is chosen because both insertion and deletion at the beginning of a singly linked list are highly efficient **O(1)** operations.

[Click here for a diagram of a Stack implemented with a Linked List](https://www.google.com/search?tbm=isch&q=stack+using+linked+list+push+pop+animation)
**What to look for:** A visual showing the `top` pointer, which is the same as the `head` of the list. Notice how `push` adds a new node at the front and updates `top`, and `pop` removes the front node and updates `top`.

### 3. Algorithm for `push(value)`

This algorithm adds a new element to the top of the stack.

**Pseudocode:**
```
Step 1: Create a new node: SET newNode = createNode(value).
Step 2: IF newNode == NULL, PRINT "Heap Overflow" and Exit.
Step 3: SET newNode->link = top
Step 4: SET top = newNode
```
**Detailed Line-by-Line Explanation:**

*   **`Step 1 & 2`**: We dynamically allocate memory for a new node using `malloc`. It's crucial to check if `malloc` returned `NULL`, which indicates the system is out of memory. This is the only "overflow" condition for a linked-list stack.
*   **`Step 3: SET newNode->link = top`**:
    *   **Purpose:** To link the new node to the rest of the stack.
    *   **Why?** The `top` pointer currently holds the address of the (previously) topmost node. We set the `link` of our `newNode` to this address. This ensures our `newNode` points to the old top, effectively placing it on top of the stack. If the stack was empty, `top` was `NULL`, so `newNode->link` correctly becomes `NULL`.
*   **`Step 4: SET top = newNode`**:
    *   **Purpose:** To update the stack's top pointer.
    *   **Why?** The `top` pointer must always point to the last element added. After linking our `newNode`, we update `top` to hold the address of `newNode`, making it the new official top of the stack.

### 4. Algorithm for `pop()`

This algorithm removes and returns the element from the top of the stack.

**Pseudocode:**
```
Step 1: IF top == NULL, PRINT "Stack Underflow" and Exit.
Step 2: Create a temporary pointer: SET temp = top.
Step 3: Get the value to return: SET value = temp->data.
Step 4: Move the top pointer down: SET top = top->link.
Step 5: Free the old top node: free(temp).
Step 6: RETURN value.
```
**Detailed Line-by-Line Explanation:**
*   **`Step 1: IF top == NULL`**:
    *   **Purpose:** The **underflow check**.
    *   **Why?** If `top` is `NULL`, the stack is empty, and there is nothing to pop.
*   **`Step 2: SET temp = top`**:
    *   **Purpose:** To save the location of the node we are about to delete.
    *   **Why?** We are about to change the `top` pointer in the next step. If we don't save the address of the current top node in `temp`, we will lose access to it and won't be able to `free()` its memory, causing a **memory leak**.
*   **`Step 3: SET value = temp->data`**:
    *   **Purpose:** To retrieve the data from the node before it is deleted.
*   **`Step 4: SET top = top->link`**:
    *   **Purpose:** To update the top of the stack.
    *   **Why?** This is the logical "removal." The `top` pointer is moved to the *next* node in the list (`top->link`), which now becomes the new top.
*   **`Step 5: free(temp)`**:
    *   **Purpose:** To release the memory of the removed node.
    *   **Why?** The node pointed to by `temp` is no longer part of the stack. We return its memory to the system to be reused.
*   **`Step 6: RETURN value`**: The retrieved value is returned to the caller.

---

### Questions

1.  **Implement a Stack using a Linked List.** Discuss the advantages of using a Linked List over an Array. (From *End Sem Exam*)
2.  In a linked-list implementation of a stack, which end of the list (head or tail) should correspond to the 'top' of the stack? Explain why this choice is made.
3.  Explain the 'pop' operation for a stack implemented using a linked list. What is the purpose of the temporary pointer in this operation?
4.  What is the time complexity of the `push` and `pop` operations for a stack implemented with a linked list?

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

**Implementation of Stack using Linked List:**
This involves defining the node structure and the core functions `push()` and `pop()`.

```c
#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* link;
};

// Global top pointer
struct Node* top = NULL;

// Push operation
void push(int value) {
    // Create a new node
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) { // Heap overflow check
        printf("Heap Overflow\n");
        return;
    }
    newNode->data = value;
    
    // Link the new node to the current top
    newNode->link = top;
    
    // Update top to be the new node
    top = newNode;
}

// Pop operation
int pop() {
    // Underflow check
    if (top == NULL) {
        printf("Stack Underflow\n");
        return -1; // Return an error value
    }
    
    // Save current top node to free it later
    struct Node* temp = top;
    int popped_value = temp->data;
    
    // Move top to the next node
    top = top->link;
    
    // Free the old top node's memory
    free(temp);
    
    return popped_value;
}
```

**Advantages of Linked List over Array for Stack Implementation:**
1.  **Dynamic Size:** A linked list can grow and shrink as needed. It is not limited by a fixed size, so the stack can never suffer from an "overflow" condition unless the system runs out of memory. An array has a fixed size and can overflow.
2.  **Efficient Memory Usage:** Memory is allocated only when an element is pushed. In an array implementation, a large block of memory might be pre-allocated and remain unused if the stack size is small, leading to wasted space.

---

#### Answer to Question 2

The **head (beginning)** of the linked list should correspond to the `top` of the stack.

**Reason:**
The choice is based entirely on **efficiency**. A stack requires its `push` and `pop` operations to be very fast.
*   **Insertion and Deletion at the Head:** Both inserting a new node at the beginning of a singly linked list and deleting the first node are **O(1)** (constant time) operations. They only require a few pointer reassignments and do not depend on the size of the list.
*   **Insertion and Deletion at the Tail:** In contrast, `pop` would be very inefficient if the tail were the top. To pop from the tail, you would need to find the *second-to-last* node to update its `link` to `NULL`. This requires traversing the entire list from the head, making the `pop` operation **O(n)** (linear time).

By using the head as the top, we ensure both `push` and `pop` are O(1), which is the expected performance of a stack.

---

#### Answer to Question 3

The `pop` operation removes the element at the top of the stack. In a linked-list implementation, this means removing the head node.

**Steps:**
1.  Check for underflow (if `top` is `NULL`).
2.  Create a temporary pointer (`temp`) and make it point to the current `top` node.
3.  Update the `top` pointer to point to the next node in the list (`top = top->link`).
4.  Retrieve the data from the node pointed to by `temp`.
5.  Free the memory pointed to by `temp`.
6.  Return the retrieved data.

**Purpose of the temporary pointer:**
The temporary pointer is essential to avoid a **memory leak**. Before we can `free` the memory of the old top node, we must first update the `top` pointer to point to the new top of the stack. If we moved `top` first without saving the address of the old top node, we would lose our only reference to it. It would still be occupying memory, but our program would have no way to access it or free it. The `temp` pointer holds on to this address so we can safely release its memory after the stack has been correctly updated.

---

#### Answer to Question 4

For a stack implemented with a linked list (where the top is the head of the list), the time complexities are:

*   **`push` operation:** **O(1)** (constant time). It involves creating a node and performing a fixed number of pointer updates at the head, regardless of the stack's size.
*   **`pop` operation:** **O(1)** (constant time). It involves a fixed number of pointer updates at the head and freeing a node, which also does not depend on the stack's size.

This excellent O(1) performance for its core operations is a key feature of this implementation.

</details>
