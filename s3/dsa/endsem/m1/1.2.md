# Module 1: Basic Concepts of Data Structures

## 1.2 Abstract Data Types (ADTs) and Data Structures

This section covers a fundamental concept in computer science: the distinction between the logical description of a data type (the "what") and its physical implementation (the "how"). Your teacher heavily emphasized this topic as a core concept for the course.

### 1. Abstract Data Type (ADT)

An **Abstract Data Type (ADT)** is a conceptual, high-level model of a data type. It acts as a **blueprint or specification**. The ADT defines two things:
1.  A collection of data.
2.  A set of operations that can be performed on that data.

Crucially, an ADT defines **WHAT** the operations do, but it **does not** specify **HOW** they are implemented or how the data is stored in memory.

This principle is known as **data abstraction** or **information hiding**. The internal workings are hidden from the user, who only interacts with a clean, simple interface.

[Click here for a diagram illustrating the ADT concept](https://www.google.com/search?tbm=isch&q=abstract+data+type+information+hiding)
**What to look for:** A diagram showing a clear boundary. On the outside, an "Application Program" calls simple functions like `push()` or `pop()`. On the inside, the complex "Implementation" is hidden.

#### Key Characteristics of an ADT
*   **Behavioral Specification:** It defines the set of values the ADT can hold and the operations that can be performed on them.
*   **Implementation Independent:** It provides no details about how the data is stored (e.g., in an array or a linked list) or how the operations are carried out.
*   **Interface:** It presents a clear interface to the user, allowing them to use the data type without needing to know its internal logic.

### 2. Data Structure

A **Data Structure** is the **concrete, low-level implementation** of an ADT. It is the specific way data is stored and organized in the computer's memory.

While the ADT is the logical concept, the data structure is the physical reality. It defines **HOW** the data is organized and **HOW** the operations are actually performed.

*   **ADT Focus:** What operations can be done.
*   **Data Structure Focus:** How data is organized and how those operations are implemented.

### 3. ADT vs. Data Structure: A Comparison

This is a very common exam question. The key is to understand that an ADT is a logical specification, and a data structure is its physical implementation.

| Feature        | Abstract Data Type (ADT)                                      | Data Structure                                                |
| :------------- | :------------------------------------------------------------ | :------------------------------------------------------------ |
| **What it is** | A logical concept, a specification, a blueprint.              | A concrete, physical implementation in memory.                |
| **Focus**      | **WHAT** operations can be done (the interface).              | **HOW** the data is organized and the operations are done.      |
| **Level**      | High-level, abstract.                                         | Low-level, concrete.                                          |
| **Visibility** | The user interacts only with the public interface (operations). | The internal details of storage and algorithms are defined here. |
| **Purpose**    | Information hiding, modularity, making code easier to manage. | Efficient storage, retrieval, and performance.                |
| **Example**    | `List`, `Stack`, `Queue`, `Map`.                              | `Array`, `Linked List`, `Hash Table`, `Binary Tree`.          |

**Analogy:**
Think of a car.
*   The **ADT** is the driver's interface: a steering wheel, accelerator, and brake pedal. You know *what* they do (turn, go, stop), but you don't need to know *how* they work.
*   The **Data Structure** is the underlying engine, steering column, and braking system. This is the actual implementation that makes the car's operations possible.

### 4. Example: The `Stack` ADT and its Implementations

As highlighted by your teacher, the Stack is a perfect example to illustrate this concept.

#### The Stack ADT
The `Stack` ADT is defined by its LIFO (Last-In-First-Out) behavior and its set of operations:
*   `push(item)`: Adds an item to the top of the stack.
*   `pop()`: Removes the item from the top of the stack.
*   `peek()`: Returns the top item without removing it.
*   `isEmpty()`: Checks if the stack is empty.

Anyone using a `Stack` only needs to know about these operations. They don't need to know how the stack is built.

#### Data Structures that Implement the Stack ADT

The `Stack` ADT can be implemented using different data structures:

**Implementation 1: Using an Array**
*   **How it works:** A fixed-size array is used to store the elements. A variable called `top` keeps track of the index of the last element pushed.
*   `push()` involves incrementing `top` and adding the element at `stack[top]`.
*   `pop()` involves returning the element at `stack[top]` and decrementing `top`.

**Implementation 2: Using a Linked List**
*   **How it works:** A collection of nodes is used, where each node contains data and a pointer to the next node. A `top` pointer always points to the first node in the list.
*   `push()` involves creating a new node and making it the new `top`.
*   `pop()` involves removing the `top` node and making the next node the new `top`.

In both cases, the ADT's interface (`push`, `pop`, etc.) remains the same for the end-user. The choice of data structure (array vs. linked list) is an implementation detail that affects performance and memory usage, but not the logical behavior of the stack.

---

### Questions

1.  Explain the concept of an Abstract Data Type (ADT) with an example. (From *Internal Test - 1*)
2.  Differentiate between an Abstract Data Type and a Data Structure.
3.  What is information hiding and how does it relate to ADTs?
4.  Can a single ADT be implemented by multiple data structures? Provide an example to support your answer.

<details>
<summary>Click to see Answers</summary>

---

#### Answer to Question 1

An **Abstract Data Type (ADT)** is a high-level, logical model for a data type. It acts as a specification or blueprint that defines:
1.  A set of data values.
2.  A set of operations that can be performed on those data values.

The key feature of an ADT is **abstraction**: it specifies *what* operations can be done but hides the details of *how* these operations are implemented and *how* the data is stored in memory.

**Example: The `List` ADT**
A `List` can be described as an ADT that represents an ordered sequence of elements. Its interface would include operations like:
*   `add(item)`: Adds an item to the list.
*   `remove(item)`: Removes an item from the list.
*   `get(index)`: Retrieves the item at a specific position.
*   `size()`: Returns the number of items in the list.

A programmer using the `List` ADT only needs to know about these functions. They don't need to know whether the list is internally built using an array or a linked list. This separation of interface from implementation is the core idea of an ADT.

---

#### Answer to Question 2

The main difference is that an ADT is a **logical concept**, while a Data Structure is a **physical implementation**.

| Feature        | Abstract Data Type (ADT)                                | Data Structure                                          |
| :------------- | :------------------------------------------------------ | :------------------------------------------------------ |
| **Level**      | High-level, abstract, conceptual.                       | Low-level, concrete, physical.                          |
| **Focus**      | **What** it does (defines the interface and behavior).  | **How** it's done (defines the actual implementation).    |
| **Concern**    | The user's point of view (operations available).        | The implementer's point of view (memory, algorithms).   |
| **Example**    | The idea of a `Stack` (LIFO behavior with push/pop).    | An `Array` or a `Linked List` used to build the stack.  |

In short: An ADT is the **"what,"** and a Data Structure is the **"how."**

---

#### Answer to Question 3

**Information Hiding** is a principle in software design where the implementation details of a component (like a data type) are hidden from the user. The user can only interact with the component through a public, well-defined interface.

**Relation to ADTs:**
ADTs are the perfect embodiment of information hiding. An ADT explicitly separates the **public interface** (the set of operations like `push`, `pop`) from the **private implementation** (the underlying data structure like an array and the code for the operations).

By doing this, an ADT provides several benefits:
*   **Simplicity:** The user doesn't have to worry about complex internal details.
*   **Modularity:** The implementation can be changed (e.g., from an array to a linked list for better performance) without affecting the code that uses the ADT, as long as the interface remains the same.
*   **Security:** It prevents the user from accidentally corrupting the data structure's internal state.

---

#### Answer to Question 4

**Yes, absolutely.** A single ADT can be implemented by multiple different data structures. The ADT is just the specification of behavior; the choice of the underlying data structure is an implementation decision based on performance trade-offs (time, space, etc.).

**Example: The `Queue` ADT**
The `Queue` ADT specifies a First-In-First-Out (FIFO) behavior with the following operations:
*   `enqueue(item)`: Adds an item to the rear of the queue.
*   `dequeue()`: Removes an item from the front of the queue.
*   `peek()`: Returns the front item without removing it.
*   `isEmpty()`: Checks if the queue is empty.

This ADT can be implemented in several ways:

1.  **Implementation with an Array:**
    *   Use an array and two pointers, `front` and `rear`.
    *   `enqueue` adds an element at the `rear` index and increments `rear`.
    *   `dequeue` removes the element at the `front` index and increments `front`.
    *   This can be inefficient if not implemented as a circular array, as the queue elements will drift down the array.

2.  **Implementation with a Singly Linked List:**
    *   Maintain two pointers, `front` and `rear`, to the first and last nodes of the list.
    *   `enqueue` adds a new node at the end (updating the `rear` pointer), which is an O(1) operation.
    *   `dequeue` removes the first node (updating the `front` pointer), which is also an O(1) operation.

Both implementations provide the exact same `Queue` behavior to the user, but they have different internal mechanics and performance characteristics.

</details>
