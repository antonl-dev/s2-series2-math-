# Module 3.1: Introduction to Trees and Binary Trees

## 1. What is a Tree?

A tree is a widely used non-linear data structure that organizes data in a hierarchical structure. Unlike linear data structures (arrays, linked lists, stacks, queues) where data is organized sequentially, a tree consists of nodes connected by edges.

**Key Definitions:**
*   **Hierarchical Structure:** It represents data with a parent-child relationship, similar to a family tree or an organizational chart.
*   **Recursive Definition:** A tree can be defined as a collection of nodes where one node is the **root**, and the remaining nodes are partitioned into disjoint sets, each of which is also a tree (called subtrees).
*   **Graph Theory Definition:** A tree is a **connected graph** that contains no circuits or loops.

[](https://www.google.com/search?q=tree+vs+graph+data+structure&tbm=isch)
*What to look for: An image comparing a graph with a cycle (not a tree) and a graph without a cycle (a tree). This visually demonstrates the "no circuits" rule.*

### 1.1 Properties of Trees
*   There is one and only one path between any two vertices in a tree.
*   A tree with 'n' vertices (nodes) has exactly `n-1` edges.
*   A graph is considered a tree if and only if it is **minimally connected**. This means if you remove even one edge, the graph becomes disconnected.

### 1.2 Basic Tree Terminology
Understanding the vocabulary is crucial for working with trees.

*   **Node:** An entity that contains a data value and pointers to its child nodes.
*   **Root:** The topmost node in the tree. It is the only node that does not have a parent.
*   **Edge:** The connecting link between two nodes.
*   **Parent:** A node that has a branch extending to another node.
*   **Child:** A node that is a descendant of another node.
*   **Siblings:** Nodes that share the same parent.
*   **Leaf Node (or External Node):** A node that has no children.
*   **Internal Node (or Non-terminal Node):** A node that has at least one child.
*   **Degree of a Node:** The total number of children a node has.
*   **Level:** The step count from the root to a node. The level of the root is 0.
*   **Height of a Node:** The number of edges on the longest path from that node to a leaf node. The height of all leaf nodes is 0.
*   **Height of a Tree:** The height of the root node.
*   **Depth of a Node:** The number of edges from the root to that node. The depth of the root is 0.
*   **Subtree:** A portion of a tree that can be viewed as a complete tree in itself.
*   **Forest:** A collection of disjoint trees.

[](https://www.google.com/search?q=basic+tree+terminology+diagram&tbm=isch)
*What to look for: A diagram of a tree with labels pointing to the root, a parent, a child, a leaf, an edge, and indicating levels and height.*

---

## 2. Binary Trees

A **Binary Tree** is a special type of tree data structure in which each node can have **at most two children**. These two children are referred to as the **left child** and the **right child**.

### 2.1 Properties of Binary Trees
*   The maximum number of nodes at any level 'L' is `2^L` (where the root is at L=0).
*   The maximum number of nodes in a binary tree of height 'H' is `2^(H+1) - 1`.
*   The minimum number of nodes in a binary tree of height 'H' is `H + 1`.
*   In any binary tree, the number of leaf nodes is one more than the number of nodes with two children.

### 2.2 Types of Binary Trees

Binary trees can be classified based on their structure and the number of children their nodes have.

*   **Full (or Strictly) Binary Tree:** A tree where every node has either **0 or 2 children**. No node has only one child.

*   **Complete Binary Tree:** A binary tree where all levels are completely filled, except possibly the last level. The last level must be filled from **left to right**.

*   **Perfect Binary Tree:** A tree that is both **full and complete**. Every internal node has exactly two children, and all leaf nodes are at the same level.

*   **Skewed Binary Tree:** A tree where every node has only one child (either all left or all right), resembling a linked list.
    *   **Left-Skewed Tree:** All nodes have only a left child.
    *   **Right-Skewed Tree:** All nodes have only a right child.

[](https://www.google.com/search?q=types+of+binary+trees+full+complete+perfect&tbm=isch)
*What to look for: A single image that shows visual examples of a Full, Complete, Perfect, and Skewed binary tree to easily compare their differences.*

---

## 3. Binary Tree Representation

A binary tree can be represented in memory in two primary ways:

### 3.1 Array (Sequential) Representation

In this method, a one-dimensional array is used to store the nodes of the tree.

*   The **root** of the tree is stored at index `0`.
*   For a node at index `i`:
    *   Its **left child** is at index `2*i + 1`.
    *   Its **right child** is at index `2*i + 2`.
    *   Its **parent** is at index `floor((i-1) / 2)`.

**Example:**
Consider a tree with root 'A', its children 'B' and 'C', and so on.

```
       A(0)
      /   \
    B(1)   C(2)
   /      /   \
 D(3)   G(5)   H(6)
```

This would be stored in an array as:
`[ A | B | C | D | - | G | H | ... ]`
Indices: `0   1   2   3   4   5   6`
(A dash `-` indicates an empty spot where a node could be).

**Advantages:**
*   Fast and easy to find the parent or children of any node.

**Disadvantages:**
*   Can be very inefficient in terms of memory. For skewed trees, a significant amount of array space is wasted.
*   The maximum size of the tree must be known in advance.

### 3.2 Linked List (Dynamic) Representation

This is the most common and efficient way to represent a tree. Each node is a structure that contains:
1.  A data field.
2.  A pointer to the left child.
3.  A pointer to the right child.

A C `struct` for a tree node would look like this:
```c
// Define the TreeNode structure
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};
```
The entire tree is accessed through a single pointer to the root node. If a child does not exist, its corresponding pointer is `NULL`.

[](https://www.google.com/search?q=linked+list+representation+of+binary+tree&tbm=isch)
*What to look for: A diagram showing nodes with three parts (left pointer, data, right pointer) and arrows connecting them to form a tree structure.*

**Advantages:**
*   Very memory-efficient, especially for skewed or sparse trees, as memory is only allocated when a node is added.
*   Dynamic size; the tree can grow or shrink at runtime.

**Disadvantages:**
*   Requires extra memory for pointers.
*   Accessing a specific node requires traversing the tree from the root.

---

## Questions

<details>
<summary>1. Define a tree and a binary tree. What are the key properties of a tree?</summary>

**Tree:** A tree is a non-linear, hierarchical data structure consisting of nodes connected by edges. It is defined as a connected graph with no cycles.
**Key Properties of a Tree:**
*   A tree with 'n' nodes has exactly 'n-1' edges.
*   There is exactly one unique path between any two nodes.
*   It is minimally connected; removing any single edge disconnects the graph.

**Binary Tree:** A binary tree is a specialized tree where each node can have at most two children, referred to as the left child and the right child.

</details>

<details>
<summary>2. Explain how a complete binary tree can be represented in an array. Given a node at index `i`, how do you find its left child, right child, and parent?</summary>

A complete binary tree is represented in a 1D array by placing the root at index 0 and then filling in each subsequent level from left to right. This representation is efficient because there are no gaps in the array until after the last node.

For a node at any given index `i`:
*   **Left Child:** The left child is located at index `(2 * i) + 1`.
*   **Right Child:** The right child is located at index `(2 * i) + 2`.
*   **Parent:** The parent is located at index `floor((i - 1) / 2)`.

These formulas allow for direct computation and O(1) time access to a node's relatives, assuming the indices are within the bounds of the array.

</details>

<details>
<summary>3. Differentiate between a Full Binary Tree and a Complete Binary Tree with examples.</summary>

*   **Full Binary Tree:** In a full (or "strictly") binary tree, every node must have either **0 or 2 children**. No node can have only one child.
    *   *Example:* A tree where the root has two children, and both of those children are leaves, is a full binary tree.

*   **Complete Binary Tree:** In a complete binary tree, all levels must be completely filled, except possibly for the last level. If the last level is not full, it must be filled from **left to right** without any gaps.
    *   *Example:* A tree where the root 'A' has children 'B' and 'C', 'B' has children 'D' and 'E', and 'C' has only a left child 'F' is a complete binary tree. However, it is *not* a full binary tree because node 'C' has only one child. A perfect binary tree is always complete, but a complete binary tree is not always perfect or full.

</details>

<details>
<summary>4. What are the advantages of using a linked list representation for a binary tree over an array representation, especially in the case of skewed trees?</summary>

The primary advantages of linked list representation over array representation are **memory efficiency** and **dynamic sizing**.

*   **Memory Efficiency for Skewed Trees:** In an array representation, space is allocated based on the potential height of the tree. A skewed tree (where each node has only one child) has a height of 'n' for 'n' nodes. In an array, this would require `2^(n+1) - 1` potential slots, most of which would be empty and wasted. In a linked representation, only 'n' nodes are allocated, each with its pointers, making it far more memory-efficient.

*   **Dynamic Sizing:** A linked representation allows the tree to grow and shrink dynamically at runtime. Nodes can be added and removed without needing to pre-allocate a large, fixed-size array. This flexibility is crucial when the size of the tree is unknown or varies significantly.

</details>
