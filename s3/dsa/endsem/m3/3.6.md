# Module 3.6: Depth First Search (DFS) and Breadth First Search (BFS)

Graph traversal (or graph search) is the process of visiting every vertex in a graph exactly once. DFS and BFS are the two most fundamental algorithms for graph traversal.

---

## 1. Depth First Search (DFS)

Depth First Search is an algorithm for traversing a graph that explores as far as possible along each branch before backtracking. It uses a **stack** data structure to keep track of the vertices to visit. This can be an explicit stack or the implicit call stack used by recursion.

The name "depth-first" comes from the fact that the search deepens from the starting vertex until it hits a dead end, and only then does it backtrack to explore other branches.

### 1.1 DFS Algorithm

1.  **Initialize:** Create a `visited` array/set to keep track of visited vertices. Choose a starting vertex.
2.  **Start Traversal:**
    *   Mark the starting vertex as visited.
    *   Push it onto the stack.
3.  **Loop:** While the stack is not empty:
    *   Pop a vertex `u` from the stack and process it (e.g., print it).
    *   For every unvisited neighbor `v` of `u`:
        *   Mark `v` as visited.
        *   Push `v` onto the stack.

*(Note: The recursive version is more common and intuitive)*

**Recursive DFS Algorithm:**
```
DFS(vertex u):
  Mark u as visited
  print(u)
  For each neighbor v of u:
    If v has not been visited:
      DFS(v)
```

### 1.2 Example of DFS

Consider the following graph (starting at vertex A):

[Click here to see a visualization of this graph](https://www.google.com/search?q=graph+for+dfs+and+bfs+example&tbm=isch)
> **What to look for:** A simple, unweighted graph with 5-7 nodes and clear connections, suitable for demonstrating both DFS and BFS traversals.

```
      A
     / \
    B---C
   /
  D---E
```
**Traversal Steps (Recursive Approach):**
1.  **Start at A.** Mark A as visited. Print A. Output: `A`
2.  Go to an unvisited neighbor of A. Let's pick **B**.
3.  **At B.** Mark B as visited. Print B. Output: `A, B`
4.  Go to an unvisited neighbor of B. Let's pick **C**.
5.  **At C.** Mark C as visited. Print C. Output: `A, B, C`
6.  Neighbors of C are A and B, both are visited. Backtrack to B.
7.  Go to another unvisited neighbor of B. Let's pick **D**.
8.  **At D.** Mark D as visited. Print D. Output: `A, B, C, D`
9.  Go to an unvisited neighbor of D. Let's pick **E**.
10. **At E.** Mark E as visited. Print E. Output: `A, B, C, D, E`
11. All neighbors of E are visited. Backtrack to D.
12. All neighbors of D are visited. Backtrack to B.
13. All neighbors of B are visited. Backtrack to A.
14. All neighbors of A are visited. Algorithm ends.

One possible DFS traversal is: **A -> B -> C -> D -> E**

[Click here to see a visualization of DFS](https://www.google.com/search?q=depth+first+search+animation&tbm=isch)
> **What to look for:** An animation where the traversal follows one path to its end before jumping back to explore a different path. It should look like it's diving deep into the graph.

**Time Complexity:** `O(V + E)`, where `V` is the number of vertices and `E` is the number of edges, because every vertex and every edge will be visited once.

---

## 2. Breadth First Search (BFS)

Breadth First Search is an algorithm for traversing a graph that explores all the neighbor nodes at the present level before moving on to the nodes at the next level. It uses a **queue** data structure to keep track of the vertices to visit.

The name "breadth-first" comes from the fact that the search broadens out, level by level, from the starting vertex.

### 2.1 BFS Algorithm

1.  **Initialize:** Create a `visited` array/set and a `queue`. Choose a starting vertex.
2.  **Start Traversal:**
    *   Mark the starting vertex as visited.
    *   Enqueue it into the queue.
3.  **Loop:** While the queue is not empty:
    *   Dequeue a vertex `u` from the front of the queue and process it (e.g., print it).
    *   For every unvisited neighbor `v` of `u`:
        *   Mark `v` as visited.
        *   Enqueue `v`.

### 2.2 Example of BFS

Using the same graph (starting at vertex A):
```
      A
     / \
    B---C
   /
  D---E
```

**Traversal Steps:**
1.  **Start at A.** Mark A as visited. Enqueue A. Queue: `[A]`
2.  Dequeue A. Print A. Output: `A`. Enqueue all unvisited neighbors of A (B and C). Queue: `[B, C]`
3.  Dequeue B. Print B. Output: `A, B`. Enqueue all unvisited neighbors of B (D). Queue: `[C, D]`
4.  Dequeue C. Print C. Output: `A, B, C`. Neighbors of C (A, B) are already visited. Queue: `[D]`
5.  Dequeue D. Print D. Output: `A, B, C, D`. Enqueue all unvisited neighbors of D (E). Queue: `[E]`
6.  Dequeue E. Print E. Output: `A, B, C, D, E`. Neighbors of E (D) is visited. Queue: `[]`
7.  The queue is now empty. The algorithm ends.

One possible BFS traversal is: **A -> B -> C -> D -> E**

*(Note: In this specific example, the traversal order happened to be the same, but the process is fundamentally different. If C had a neighbor F, BFS would be A->B->C->D->F while DFS might be A->B->D->E->C->F)*

[Click here to see a visualization of BFS](https://www.google.com/search?q=breadth+first+search+animation&tbm=isch)
> **What to look for:** An animation where the traversal starts at a node, then visits all of its immediate neighbors, then visits all of *their* neighbors, and so on. It should look like a wave expanding from the source.

**Time Complexity:** `O(V + E)`, same as DFS.

---

## 3. Comparison: DFS vs. BFS

| Feature               | Depth First Search (DFS)                               | Breadth First Search (BFS)                         |
|-----------------------|--------------------------------------------------------|----------------------------------------------------|
| **Data Structure**    | **Stack** (or recursion)                               | **Queue**                                          |
| **Exploration**       | Goes deep down a path before exploring alternatives.   | Explores level by level (all neighbors first).     |
| **Finding a Path**    | Good for finding *any* path between two vertices.      | Finds the **shortest path** (in terms of edges).   |
| **Memory Usage**      | Can be more memory-efficient if the graph is broad.    | Can be memory-intensive if the graph is very broad.|
| **Common Applications** | Topological sorting, cycle detection, solving puzzles (mazes). | Finding shortest paths, web crawling, network broadcasting. |

---

## Questions

<details>
<summary>1. Explain the main difference in the data structures used by DFS and BFS and how that influences their traversal behavior.</summary>

The main difference is that **DFS uses a stack (LIFO)** while **BFS uses a queue (FIFO)**.

*   **DFS (Stack):** When DFS visits a node, it pushes its neighbors onto a stack. Since a stack is Last-In, First-Out, the most recently discovered neighbor is the very next node to be explored. This causes the algorithm to immediately go deeper down the newly discovered path, leading to its "depth-first" behavior.
*   **BFS (Queue):** When BFS visits a node, it enqueues its neighbors. A queue is First-In, First-Out. This means the algorithm will finish exploring all the neighbors of the current node (which were enqueued first) before it starts exploring the neighbors of those neighbors. This results in a level-by-level, "breadth-first" exploration.
</details>

<details>
<summary>2. You need to find the shortest path (in terms of the number of edges) from one node to another in an unweighted graph. Which algorithm, DFS or BFS, is guaranteed to find it? Why?</summary>

**BFS (Breadth First Search)** is guaranteed to find the shortest path in an unweighted graph.

**Why:** BFS explores the graph level by level, starting from the source node. It first visits all nodes at distance 1, then all nodes at distance 2, and so on. Because it explores in this expanding wave, the first time it reaches the destination node, it must have done so via the shortest possible path (in terms of the number of edges). DFS, on the other hand, might explore a very long, winding path deep into the graph before it happens to find the destination, with no guarantee that this path is the shortest.
</details>

<details>
<summary>3. Perform both a DFS and a BFS traversal on the following graph, starting from vertex `0`. List the order in which vertices are visited. (For neighbors, visit them in increasing numerical order).</summary>
<br>

*A diagram showing a graph with vertices 0-5 and edges (0,1), (0,2), (1,3), (1,4), (2,5)*

**DFS Traversal (Starting from 0):**
1.  Visit 0.
2.  From 0, go to 1.
3.  From 1, go to 3.
4.  From 3, backtrack to 1.
5.  From 1, go to 4.
6.  From 4, backtrack to 1, then to 0.
7.  From 0, go to 2.
8.  From 2, go to 5.
**DFS Order:** `0, 1, 3, 4, 2, 5`

**BFS Traversal (Starting from 0):**
1.  Visit 0. Queue: `[0]`
2.  Dequeue 0. Visit its neighbors 1 and 2. Queue: `[1, 2]`
3.  Dequeue 1. Visit its neighbors 3 and 4. Queue: `[2, 3, 4]`
4.  Dequeue 2. Visit its neighbor 5. Queue: `[3, 4, 5]`
5.  Dequeue 3. (No new neighbors). Queue: `[4, 5]`
6.  Dequeue 4. (No new neighbors). Queue: `[5]`
7.  Dequeue 5. (No new neighbors). Queue: `[]`
**BFS Order:** `0, 1, 2, 3, 4, 5`
</details>
