# Module 3.4: Binary Search Trees (BST)

## 1. What is a Binary Search Tree?

A **Binary Search Tree (BST)**, also known as an ordered or sorted binary tree, is a special type of binary tree with a specific ordering property that makes operations like searching, insertion, and deletion highly efficient.

The fundamental property of a BST is:
> For any given node `N`, all values in its **left subtree** are **less than** `N`'s value, and all values in its **right subtree** are **greater than** `N`'s value.

### Key Properties of a BST:
*   **Ordering Property:** The left-subtree < Node < right-subtree rule must hold true for every node in the tree.
*   **Recursive Structure:** Both the left and right subtrees of any node must also be binary search trees.
*   **No Duplicates:** Standard BSTs typically do not allow duplicate values. If a new value is equal to an existing node's value, it is usually ignored or handled based on the specific implementation.
*   **Efficient Operations:** The ordering property allows for fast searching, insertion, and deletion, with an average time complexity of **O(log n)**.

[Click here to see a visualization of a Binary Search Tree](https://www.google.com/search?q=binary+search+tree+property+example&tbm=isch)
> **What to look for:** A diagram of a binary tree where for every node, all nodes in the left branch have smaller values and all nodes in the right branch have larger values.

---

## 2. Operations on a Binary Search Tree

The ordering property of a BST dictates how all its core operations are performed.

### 2.1 Searching in a BST

Searching for a value is a straightforward process of elimination. Starting from the root, you compare the target value with the current node's value.

**Algorithm for `search(root, key)`:**
1.  Start at the `root`. If the tree is empty (`root == NULL`), the key is not found.
2.  Compare the `key` with `root->data`:
    *   If `key == root->data`, the element is found.
    *   If `key < root->data`, the key must be in the left subtree. Recursively call `search(root->left, key)`.
    *   If `key > root->data`, the key must be in the right subtree. Recursively call `search(root->right, key)`.
3.  Repeat step 2 until the key is found or you reach a `NULL` pointer (meaning the key is not in the tree).

**Time Complexity:**
*   **Average Case:** O(log n) for a balanced tree.
*   **Worst Case:** O(n) for a completely unbalanced (skewed) tree, which degrades to a linear search.

[Click here to see a visualization of searching in a BST](https://www.google.com/search?q=searching+in+binary+search+tree+animation&tbm=isch)
> **What to look for:** An animation showing a search for a value. The path will move left for smaller values and right for larger values until the target is found or a null link is reached.

### 2.2 Insertion into a BST

To insert a new node, you first search for the value. The search will end at a `NULL` link, which is precisely where the new node should be attached.

**Algorithm for `insert(root, value)`:**
1.  If the tree is empty (`root == NULL`), create a new node with the given `value` and return it as the new root.
2.  If `value < root->data`, recursively call `insert` on the left child: `root->left = insert(root->left, value)`.
3.  If `value > root->data`, recursively call `insert` on the right child: `root->right = insert(root->right, value)`.
4.  Return the `root` pointer (unchanged, unless it was the first insertion).

[Click here to see a visualization of insertion into a BST](https://www.google.com/search?q=insertion+in+binary+search+tree+animation&tbm=isch)
> **What to look for:** A step-by-step animation of building a BST. Observe how each new node is inserted by traversing down from the root to find its correct empty spot.

### 2.3 Deletion from a BST

Deletion is the most complex operation because the BST properties must be maintained after the node is removed. There are three cases to consider for the node to be deleted:

**Case 1: The node is a leaf (has 0 children).**
*   This is the simplest case. Simply remove the node and set its parent's corresponding child pointer to `NULL`.

**Case 2: The node has one child.**
*   "Bypass" the node by linking its parent directly to its child. The node to be deleted is then removed.

**Case 3: The node has two children.**
*   This is the most complex case. You cannot simply remove the node as it would disconnect the tree.
    1.  Find a replacement node that maintains the BST property. The two standard choices are:
        *   The **in-order successor:** The smallest node in the node's right subtree.
        *   The **in-order predecessor:** The largest node in the node's left subtree.
    2.  Copy the value of the replacement node into the node to be deleted.
    3.  Delete the original replacement node (which will now be a Case 1 or Case 2 deletion, a much simpler problem).

[Click here to see a visualization of all three deletion cases](https://www.google.com/search?q=deletion+in+binary+search+tree+all+cases+animation&tbm=isch)
> **What to look for:** An animation that demonstrates all three scenarios: deleting a leaf, deleting a node with one child, and deleting a node with two children by finding its in-order successor.

---

## 3. C Implementation Example (Insert and Delete)

The following C code provides functions for inserting and deleting nodes from a BST.

```c
#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node *left, *right;
};

// Function to create a new node
struct Node* newNode(int value) {
    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
    temp->data = value;
    temp->left = temp->right = NULL;
    return temp;
}

// Insert a node into the BST
struct Node* insert(struct Node* root, int value) {
    // If the tree is empty, return a new node
    if (root == NULL) return newNode(value);

    // Otherwise, recur down the tree
    if (value < root->data)
        root->left = insert(root->left, value);
    else if (value > root->data)
        root->right = insert(root->right, value);

    // Return the (unchanged) node pointer
    return root;
}

// Find the in-order successor (smallest value in a subtree)
struct Node* minValueNode(struct Node* node) {
    struct Node* current = node;
    // Loop down to find the leftmost leaf
    while (current && current->left != NULL)
        current = current->left;
    return current;
}

// Delete a node from the BST
struct Node* deleteNode(struct Node* root, int key) {
    if (root == NULL) return root;

    // Find the node to be deleted
    if (key < root->data)
        root->left = deleteNode(root->left, key);
    else if (key > root->data)
        root->right = deleteNode(root->right, key);
    else {
        // Case 1 & 2: Node with one or no child
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }

        // Case 3: Node with two children
        // Get the in-order successor (smallest in the right subtree)
        struct Node* temp = minValueNode(root->right);

        // Copy the successor's content to this node
        root->data = temp->data;

        // Delete the in-order successor
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}
```

---

## Questions

<details>
<summary>1. Show the structure of the binary search tree after adding the following values in order: `25, 55, 71, 10, 9, 11, 6, 67, 45, 23`. What is the height of the created tree?</summary>

1.  Insert 25 (root)
2.  Insert 55 (right of 25)
3.  Insert 71 (right of 55)
4.  Insert 10 (left of 25)
5.  Insert 9 (left of 10)
6.  Insert 11 (right of 10)
7.  Insert 6 (left of 9)
8.  Insert 67 (left of 71)
9.  Insert 45 (left of 55)
10. Insert 23 (right of 11)

The final tree structure is:
```
          25
         /  \
        10   55
       /  \   /  \
      9   11 45  71
     /      \   /
    6       23 67
```
The **height of the tree** (longest path from root to leaf) is **3**. The path is 25 -> 10 -> 9 -> 6.

</details>

<details>
<summary>2. A university stores student IDs in a BST: `{45, 32, 78, 20, 40, 50}`. An online retail system stores product IDs in a BST: `{500, 300, 700, 200, 400, 600, 800}`. Why is a BST a suitable data structure for these applications?</summary>

A BST is suitable for both applications because it provides efficient **searching, insertion, and deletion** of records.
*   **University IDs:** When a new student enrolls, their ID can be quickly inserted. When checking if a student is already registered, their ID can be searched for in O(log n) average time, which is much faster than searching an unsorted list (O(n)).
*   **Retail Inventory:** Product IDs can be added, removed (when sold out), and looked up quickly. This is crucial for real-time inventory management, where speed is essential. The ability to retrieve data in sorted order (via in-order traversal) is also useful for generating reports.
</details>

<details>
<summary>3. In the retail system BST `{500, 300, 700, 200, 400, 600, 800}`, you need to delete product 700. Which case of BST deletion applies, and why? Show the tree before and after deletion.</summary>

**Before Deletion:**
```
      500
     /   \
    300   700
   /  \   /  \
  200 400 600 800
```
**Case Analysis:**
The node to be deleted (700) has **two children** (600 and 800). Therefore, **Case 3** of BST deletion applies.

**Deletion Process:**
1.  Find the **in-order successor** of 700 (the smallest value in its right subtree). The right subtree is `(800)`. The smallest value is **800**.
2.  Copy the value of the successor (800) into the node to be deleted.
3.  Delete the original successor node (800). Since this node is a leaf, this becomes a simple Case 1 deletion.

**After Deletion:**
```
      500
     /   \
    300   800
   /  \   /
  200 400 600
```
</details>
