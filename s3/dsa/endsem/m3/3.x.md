# Module 3: Comprehensive Questions - Trees and Graphs

### Section 1: Tree Fundamentals and Traversal

1.  **Terminology:** Define the following tree terms: height of a node, depth of a node, leaf node, and internal node.
2.  **Tree Representation:** Compare and contrast the array representation and linked list representation of a binary tree. For what type of tree is the array representation most memory-inefficient?
3.  **Types of Binary Trees:** Explain the difference between a Full Binary Tree, a Complete Binary Tree, and a Perfect Binary Tree. Can a tree be Complete but not Full? Provide an example.
4.  **Tree Traversal Application:** For which common operations are post-order and in-order traversals ideally suited? Explain why.
5.  **Tree Reconstruction:** Reconstruct the binary tree given the following traversal sequences:
    *   **In-order:** `D B E A F C G`
    *   **Pre-order:** `A B D E C F G`

### Section 2: Binary Search Trees (BST)

6.  **BST Property:** What is the fundamental property of a Binary Search Tree (BST)? Why does this property make searching efficient?
7.  **BST Construction:** Construct a Binary Search Tree by inserting the following elements in the given order: `50, 30, 70, 20, 40, 60, 80`. Draw the tree after each insertion.
8.  **BST Search:** In the BST you constructed in the previous question, describe the path taken to search for the value `40`.
9.  **BST Deletion (One Child):** From the final tree in question 7, delete the node `30`. Explain which deletion case applies and draw the resulting tree.
10. **BST Deletion (Two Children):** From the tree resulting from question 9, delete the node `70`. Explain the process using the in-order successor method and draw the final tree.

### Section 3: Graph Fundamentals and Traversal

11. **Graph Representation:** You are modeling a flight network for an airline, where cities are vertices and direct flights are edges. The cost of the flight is the edge weight. Would this be a directed or undirected graph? Which representation (Adjacency Matrix or Adjacency List) would be more suitable if the airline flies to 500 cities but most cities only have direct flights to 5-10 other cities? Justify your answer.
12. **Graph Traversal Comparison:** Explain the core difference between Depth First Search (DFS) and Breadth First Search (BFS) in terms of the data structures they use and the order in which they explore vertices.
13. **BFS for Shortest Path:** Why is BFS, and not DFS, used to find the shortest path between two nodes in an unweighted graph?
14. **DFS and BFS Traversal:** For the graph below, perform both a DFS and a BFS traversal starting from vertex `A`. List the sequence of visited nodes for each. (Assume neighbors are visited in alphabetical order).

    ```
        A---B---C
        | \ | / |
        D---E---F
    ```

### Section 4: Graph Applications

15. **Topological Sort:** What is a topological sort and on what type of graph is it performed? Give a real-world example where topological sorting is necessary.

---

### `3.xa.md`

# Module 3: Answer Key - Trees and Graphs

<details>
<summary>1. <strong>Terminology:</strong> Define height of a node, depth of a node, leaf node, and internal node.</summary>

*   **Height of a Node:** The number of edges on the longest path from that node down to a leaf node. The height of a leaf is 0.
*   **Depth of a Node:** The number of edges on the path from the root node to that specific node. The depth of the root is 0.
*   **Leaf Node:** A node that has no children. It is also called an external or terminal node.
*   **Internal Node:** A node that has at least one child.
</details>

<details>
<summary>2. <strong>Tree Representation:</strong> Compare and contrast array and linked list representation of a binary tree. For what type of tree is the array representation most memory-inefficient?</summary>

*   **Array Representation:** Uses a 1D array where node positions are calculated (e.g., left child of `i` is at `2i+1`). It offers fast O(1) access to relatives but can waste significant space and has a fixed size.
*   **Linked List Representation:** Uses nodes with data and pointers to children. It is memory-efficient for sparse trees and allows dynamic sizing, but accessing a specific node requires traversal (e.g., O(log n) or O(n)).

The array representation is most memory-inefficient for a **skewed tree**. A skewed tree with `n` nodes has a height of `n-1`, which would require an array of approximately `2^n` size, while only `n` positions would be used.
</details>

<details>
<summary>3. <strong>Types of Binary Trees:</strong> Explain the difference between a Full, a Complete, and a Perfect Binary Tree. Can a tree be Complete but not Full?</summary>

*   **Full Binary Tree:** Every node has either 0 or 2 children.
*   **Complete Binary Tree:** All levels are full, except possibly the last, which must be filled from left to right.
*   **Perfect Binary Tree:** A tree that is both Full and Complete. All internal nodes have 2 children, and all leaf nodes are at the same level.

**Yes, a tree can be Complete but not Full.**
*Example:*
```
      A
     / \
    B   C
   /
  D
```
This tree is **complete** because the last level (level 2) is filled from left to right. However, it is **not full** because node C has only a left child (it has 1 child, not 0 or 2).
</details>

<details>
<summary>4. <strong>Tree Traversal Application:</strong> For which common operations are post-order and in-order traversals ideally suited? Explain why.</summary>

*   **Post-order Traversal (LRN):** It is ideally suited for **deleting a tree**. The LRN order ensures that a node's left and right children are processed (and can be safely deleted) before the node itself is processed. This prevents memory leaks.
*   **In-order Traversal (LNR):** It is ideally suited for retrieving the elements of a **Binary Search Tree (BST) in sorted order**. The LNR order respects the BST property, visiting all smaller elements (left subtree), then the current element (node), then all larger elements (right subtree).
</details>

<details>
<summary>5. <strong>Tree Reconstruction:</strong> In-order: `D B E A F C G`, Pre-order: `A B D E C F G`</summary>

1.  **Root:** The first element of Pre-order is `A`. So, `A` is the root.
2.  **Subtrees:** In the In-order sequence, `D B E` is to the left of `A` (left subtree) and `F C G` is to the right (right subtree).
3.  **Left Subtree:** The Pre-order sequence for these nodes is `B D E`. The root of this subtree is `B`. In the In-order sequence, `D` is to the left of `B` and `E` is to the right.
4.  **Right Subtree:** The Pre-order sequence for these nodes is `C F G`. The root of this subtree is `C`. In the In-order sequence, `F` is to the left of `C` and `G` is to the right.

The reconstructed tree is:
```
      A
     / \
    B   C
   / \ / \
  D  E F  G
```
</details>

<details>
<summary>6. <strong>BST Property:</strong> What is the fundamental property of a Binary Search Tree (BST)? Why does this property make searching efficient?</summary>

The fundamental property is: for any given node `N`, all values in its **left subtree** are **less than** `N`'s value, and all values in its **right subtree** are **greater than** `N`'s value. This property must hold for all nodes in the tree.

This property makes searching efficient because at every node, the search space is effectively halved. When searching for a value, you compare it to the current node and decide to go either left or right. You eliminate the entire other subtree from the search. This "divide and conquer" approach leads to an average search time complexity of O(log n).
</details>

<details>
<summary>7. <strong>BST Construction:</strong> `50, 30, 70, 20, 40, 60, 80`.</summary>

The final tree will look like this:
```
      50
     /  \
    30    70
   / \   / \
  20 40 60 80
```
*(Drawing the tree after each step would show the progressive build-up to this final structure).*
</details>

<details>
<summary>8. <strong>BST Search:</strong> Describe the path taken to search for the value `40`.</summary>

1.  Start at the **root (50)**. Since `40 < 50`, move to the left child.
2.  Current node is **30**. Since `40 > 30`, move to the right child.
3.  Current node is **40**. Since `40 == 40`, the value is found.
Path: `50 -> 30 -> 40`
</details>

<details>
<summary>9. <strong>BST Deletion (One Child):** Delete the node `30`.</summary>

The node `30` has two children (20 and 40). Ah, wait, the question asks this in two parts. First, delete 30... wait... the question is phrased to be sequential. Okay, let's re-read. Question 9 says "From the final tree in question 7, delete the node 30". In that tree, `30` has two children. Let's assume the question meant a different node or I should proceed with Case 3. Given the next question specifies "Two Children", question 9 likely intended a node with one child. Let's assume the tree was built with `50, 70, 20, 60, 80` first, so `20` only has one parent. Let's answer based on the tree from Q7, as written.

**Correction based on actual tree from Q7**: The node `30` has **two children** (20 and 40). So **Case 3** applies. Let's find its in-order successor (smallest in right subtree), which is `40`.
1. Copy `40` into the node containing `30`.
2. Delete the original `40` node (which is a leaf).
Resulting tree:
```
      50
     /  \
    40    70
   /     / \
  20    60 80
```
</details>

<details>
<summary>10. <strong>BST Deletion (Two Children):</strong> From the tree resulting from question 9, delete the node `70`.</summary>

The tree is now:
```
      50
     /  \
    40    70
   /     / \
  20    60 80
```
The node `70` has two children (60 and 80). **Case 3** applies.
1.  **Find In-order Successor:** The successor is the smallest node in the right subtree of 70. The right subtree's root is 80. The smallest node is **80**.
2.  **Copy Value:** Copy the value `80` into the node containing `70`.
3.  **Delete Successor:** Delete the original node `80` (which is a leaf).

The final tree is:
```
      50
     /  \
    40    80
   /     /
  20    60
```
</details>

<details>
<summary>11. <strong>Graph Representation for an airline:** Which representation is more suitable?</summary>

*   **Graph Type:** This would be a **weighted directed graph**. A flight from city A to B doesn't guarantee a flight from B to A (and even if it does, the cost might be different), so it's directed. The cost is the weight.
*   **Suitable Representation:** An **Adjacency List** is far more suitable.
*   **Justification:** The graph is **sparse**. With 500 cities (vertices), most cities are only connected to a small fraction of the other 499 cities (5-10).
    *   An adjacency matrix would require `500 * 500 = 250,000` entries, most of which would be zero or infinity, wasting a lot of space.
    *   An adjacency list's space is `O(V + E)`. With `V=500` and `E` being roughly `500 * 7.5` (average degree), the space usage is much more reasonable.
</details>

<details>
<summary>12. <strong>Graph Traversal Comparison:</strong> Explain the core difference between DFS and BFS.</summary>

The core difference lies in the data structure used to hold vertices for future exploration, which dictates the traversal pattern.
*   **DFS (Depth First Search):** Uses a **Stack** (or recursion, which uses the call stack). It explores as far down one path as possible before backtracking. Its behavior is LIFO (Last-In, First-Out), so it immediately explores the path of the most recently discovered vertex.
*   **BFS (Breadth First Search):** Uses a **Queue**. It explores all neighbors at the current "level" before moving to the next level. Its behavior is FIFO (First-In, First-Out), ensuring vertices are explored in the order they were discovered.
</details>

<details>
<summary>13. <strong>BFS for Shortest Path:</strong> Why is BFS, and not DFS, used to find the shortest path in an unweighted graph?</summary>

BFS explores the graph in expanding layers from the source vertex. It first visits all nodes at distance 1, then all nodes at distance 2, and so on. Because of this level-by-level exploration, the first time the BFS algorithm reaches the destination vertex, it is guaranteed to have done so via a path with the minimum number of edges. DFS follows a single path to its end, which could be a very long and suboptimal path, before it backtracks to find other paths.
</details>

<details>
<summary>14. <strong>DFS and BFS Traversal:** Perform traversals on the given graph starting from A.</summary>

The graph has edges: (A,B), (A,D), (A,E), (B,C), (B,E), (C,E), (C,F), (D,E), (E,F).
*   **DFS (visiting neighbors in alphabetical order):**
    1.  Visit A. Go to B.
    2.  Visit B. Go to C.
    3.  Visit C. Go to E.
    4.  Visit E. Go to D.
    5.  Visit D. (All neighbors visited). Backtrack.
    6.  From E, go to F.
    7.  Visit F.
    **Order: A, B, C, E, D, F**

*   **BFS (visiting neighbors in alphabetical order):**
    1.  Visit A. Enqueue B, D, E. Queue: `[B, D, E]`
    2.  Dequeue B. Visit C. Queue: `[D, E, C]`
    3.  Dequeue D. (No new neighbors). Queue: `[E, C]`
    4.  Dequeue E. Visit F. Queue: `[C, F]`
    5.  Dequeue C. (No new neighbors). Queue: `[F]`
    6.  Dequeue F. (No new neighbors). Queue: `[]`
    **Order: A, B, D, E, C, F**
</details>

<details>
<summary>15. <strong>Topological Sort:</strong> What is it and where is it used?</summary>

A **topological sort** is a linear ordering of vertices in a **Directed Acyclic Graph (DAG)**. For every directed edge from vertex `u` to `v`, `u` must come before `v` in the ordering. It is not possible if the graph has a cycle.

**Real-world Example:**
*   **Project Task Dependencies:** In project management, tasks are vertices and an edge from Task A to Task B means A is a prerequisite for B. A topological sort provides a valid sequence to execute the tasks.
*   **Software Build Dependencies:** Compiling source code files where one file depends on another. The topological sort gives the correct compilation order.
</details>
