
# Module 3.2: Tree Traversals

## 1. Introduction to Tree Traversal

Tree traversal refers to the process of visiting (checking, updating, or printing) each node in a tree data structure exactly once. Since trees are not linear, there are multiple systematic ways to visit the nodes.

The two main strategies for traversal are:
1.  **Depth-First Search (DFS):** This strategy goes as deep as possible down one branch before backing up. Pre-order, In-order, and Post-order are the three main types of DFS for binary trees.
2.  **Breadth-First Search (BFS):** This strategy explores nodes level by level, visiting all nodes on one level before moving to the next. (This is also known as Level-Order Traversal and is often discussed with Graphs).

This section focuses on the three Depth-First Search traversals. The order is determined by the position of the **Root (Node)** relative to its left and right subtrees.

*   **Pre-order:** **N**ode -> **L**eft -> **R**ight
*   **In-order:** **L**eft -> **N**ode -> **R**ight
*   **Post-order:** **L**eft -> **R**ight -> **N**ode

---

## 2. Pre-order Traversal (NLR)

In a pre-order traversal, the root node is visited first, followed by the recursive traversal of the left subtree and then the right subtree.

**Order of Operations:**
1.  Visit the **Root (Node)**.
2.  Traverse the entire **Left** subtree.
3.  Traverse the entire **Right** subtree.

This is often used to create a copy of a tree or to get a prefix expression from an expression tree.

**Algorithm:**
```c
void preOrder(struct TreeNode* root) {
    if (root != NULL) {
        printf("%d ", root->data); // 1. Visit the Node
        preOrder(root->left);      // 2. Traverse Left Subtree
        preOrder(root->right);     // 3. Traverse Right Subtree
    }
}
```

**Example:**
For the following tree:
```
       A
      / \
     B   C
    / \
   D   E
```
The pre-order traversal would be: **A, B, D, E, C**

[Click here to see a visualization of Pre-order Traversal](https://www.google.com/search?q=pre-order+tree+traversal+animation&tbm=isch)
> **What to look for:** An animation or diagram that shows the path of traversal. For pre-order, the path traces the perimeter of the tree, and a node is "visited" (added to the output) the first time the path passes it on the left.

---

## 3. In-order Traversal (LNR)

In an in-order traversal, the left subtree is traversed first, then the root node is visited, and finally, the right subtree is traversed.

**Order of Operations:**
1.  Traverse the entire **Left** subtree.
2.  Visit the **Root (Node)**.
3.  Traverse the entire **Right** subtree.

**Key Property:** For a **Binary Search Tree (BST)**, an in-order traversal visits the nodes in ascending (sorted) order.

**Algorithm:**
```c
void inOrder(struct TreeNode* root) {
    if (root != NULL) {
        inOrder(root->left);      // 1. Traverse Left Subtree
        printf("%d ", root->data); // 2. Visit the Node
        inOrder(root->right);     // 3. Traverse Right Subtree
    }
}
```

**Example:**
For the same tree:
```
       A
      / \
     B   C
    / \
   D   E
```
The in-order traversal would be: **D, B, E, A, C**

[Click here to see a visualization of In-order Traversal](https://www.google.com/search?q=in-order+tree+traversal+animation&tbm=isch)
> **What to look for:** An animation showing the traversal path. For in-order, a node is "visited" when the path passes underneath it. The traversal always goes to the absolute leftmost descendant first.

---

## 4. Post-order Traversal (LRN)

In a post-order traversal, the left and right subtrees are traversed first, and the root node is visited last.

**Order of Operations:**
1.  Traverse the entire **Left** subtree.
2.  Traverse the entire **Right** subtree.
3.  Visit the **Root (Node)**.

This method is commonly used to **delete a tree** from memory, as you must delete a node's children before you can delete the node itself. It is also used to get the postfix expression from an expression tree.

**Algorithm:**
```c
void postOrder(struct TreeNode* root) {
    if (root != NULL) {
        postOrder(root->left);     // 1. Traverse Left Subtree
        postOrder(root->right);    // 2. Traverse Right Subtree
        printf("%d ", root->data); // 3. Visit the Node
    }
}
```

**Example:**
For the same tree:
```
       A
      / \
     B   C
    / \
   D   E
```
The post-order traversal would be: **D, E, B, C, A**

[Click here to see a visualization of Post-order Traversal](https://www.google.com/search?q=post-order+tree+traversal+animation&tbm=isch)
> **What to look for:** An animation showing the traversal path. For post-order, a node is "visited" the last time the path passes it on the right, as it returns up the tree. The root node is always the very last node visited.

---

## 5. C Implementation Example

This code demonstrates how to create a simple binary tree and perform all three traversals.

```c
#include <stdio.h>
#include <stdlib.h>

// Define the TreeNode structure
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

// Function to create a new node
struct TreeNode* createNode(int value) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// In-Order Traversal (LNR)
void inOrder(struct TreeNode* root) {
    if (root != NULL) {
        inOrder(root->left);
        printf("%d ", root->data);
        inOrder(root->right);
    }
}

// Pre-Order Traversal (NLR)
void preOrder(struct TreeNode* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preOrder(root->left);
        preOrder(root->right);
    }
}

// Post-Order Traversal (LRN)
void postOrder(struct TreeNode* root) {
    if (root != NULL) {
        postOrder(root->left);
        postOrder(root->right);
        printf("%d ", root->data);
    }
}

int main() {
    // Manually creating a tree:
    //      1
    //     / \
    //    2   3
    //   / \
    //  4   5
    struct TreeNode* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    root->left->left = createNode(4);
    root->left->right = createNode(5);

    printf("Pre-Order Traversal: ");
    preOrder(root);
    printf("\n");

    printf("In-Order Traversal: ");
    inOrder(root);
    printf("\n");

    printf("Post-Order Traversal: ");
    postOrder(root);
    printf("\n");

    return 0;
}
```
**Output of the code:**
```
Pre-Order Traversal: 1 2 4 5 3
In-Order Traversal: 4 2 5 1 3
Post-Order Traversal: 4 5 2 3 1
```

---

## Questions

<details>
<summary>1. Given the In-order traversal `E A C K F H D B G` and Pre-order traversal `F A E K C D H G B` of a binary tree, reconstruct the tree.</summary>

This is a classic problem solved by understanding the properties of traversals.
1.  The **first** element in the **Pre-order** sequence is always the **root** of the tree (or subtree). Here, it is **F**.
2.  Find the root (`F`) in the **In-order** sequence. All elements to its **left** (`E A C K`) belong to the left subtree, and all elements to its **right** (`H D B G`) belong to the right subtree.
3.  **Left Subtree:** Pre-order is `A E K C`, In-order is `E A C K`. The root is `A`. In the in-order sequence, `E` is to the left of `A`, and `C K` are to the right.
4.  **Right Subtree:** Pre-order is `B H D G`, In-order is `H D B G`. The root is `B`. In the in-order sequence, `H D` are to the left of `B`, and `G` is to the right.
5.  Continue this process recursively.

The final tree structure is:
```
          F
         / \
        A   B
       / \   \
      E   C   G
         /   /
        K   D
           /
          H
```
</details>

<details>
<summary>2. What is the primary use case for post-order traversal? Explain why it is suitable for this task.</summary>

The primary use case for post-order traversal is **deleting a tree** and freeing its allocated memory.

**Reasoning:** Post-order traversal follows the **Left -> Right -> Node** sequence. This means it visits and processes both children of a node *before* visiting the parent node itself. When deleting, you must free the memory of the children before freeing the parent. If you delete the parent first, the pointers to its children are lost, leading to a memory leak because those child subtrees become inaccessible and cannot be freed. Post-order guarantees a safe, bottom-up deletion process.
</details>

<details>
<summary>3. For a given Binary Search Tree (BST), which traversal method will always produce a sorted sequence of its elements? Explain why.</summary>

**In-order traversal (Left -> Node -> Right)** will always produce a sorted sequence of elements from a Binary Search Tree.

**Reasoning:** The fundamental property of a BST is that for any given node, all values in its left subtree are smaller than the node's value, and all values in its right subtree are greater. The in-order traversal algorithm honors this property perfectly:
1.  It recursively visits the **left subtree** first (all the smaller values).
2.  Then it visits the **node** itself (the middle value).
3.  Finally, it recursively visits the **right subtree** (all the larger values).

This `(smaller) -> (current) -> (larger)` pattern, when applied recursively down the entire tree, results in visiting all nodes in ascending order.
</details>
