# Module 3.5: Graph Representation

## 1. Introduction to Graphs

A **graph** is a non-linear data structure consisting of a finite set of **vertices** (or nodes) and a set of **edges** that connect these vertices. A graph `G` is formally defined as an ordered pair `G = (V, E)`, where:
*   `V` is the set of vertices.
*   `E` is the set of edges.

Graphs are used to model relationships and networks in various fields, such as social networks, computer networks, and mapping applications.

**Basic Graph Terminology:**
*   **Undirected Graph:** Edges have no orientation. An edge `(u, v)` is the same as `(v, u)`.
*   **Directed Graph (Digraph):** Edges have a direction. An edge `(u, v)` goes from vertex `u` (origin) to vertex `v` (destination).
*   **Weighted Graph:** Each edge is assigned a numerical value or "weight," representing a cost, distance, or capacity.

To work with graphs programmatically, we need a way to store their structure in memory. The two most common methods are the Adjacency Matrix and the Adjacency List.

---

## 2. Adjacency Matrix Representation

An **adjacency matrix** is a 2D array of size `V x V`, where `V` is the number of vertices in the graph. The entry `matrix[i][j]` represents the relationship between vertex `i` and vertex `j`.

**Rules:**
*   For an **unweighted graph**, `matrix[i][j] = 1` if there is an edge from vertex `i` to vertex `j`; otherwise, `matrix[i][j] = 0`.
*   For a **weighted graph**, `matrix[i][j]` stores the weight of the edge between `i` and `j`. If no edge exists, the value is often set to `0` or `âˆž` (a large number).
*   For an **undirected graph**, the matrix is symmetric (`matrix[i][j] == matrix[j][i]`).
*   For a **directed graph**, the matrix is not necessarily symmetric.

**Example: Undirected Graph**

```
      (A) --- (B)
       | \     |
       |  \    |
      (D) --- (C)
```
Vertices: A=0, B=1, C=2, D=3

**Adjacency Matrix:**
```
    A B C D
  A[0 1 0 1]
  B[1 0 1 0]
  C[0 1 0 1]
  D[1 0 1 0]
```

[Click here to see a visualization of an Adjacency Matrix](https://www.google.com/search?q=graph+adjacency+matrix+example&tbm=isch)
> **What to look for:** A diagram showing a simple graph on one side and a corresponding 2D grid (the matrix) on the other. Trace an edge between two vertices in the graph and see the '1' at the intersection of the corresponding row and column in the matrix.

**Advantages:**
*   **Fast Edge Lookup:** Checking if an edge exists between two vertices `i` and `j` is an O(1) operation (`matrix[i][j]`).
*   Simple to implement.

**Disadvantages:**
*   **Space Inefficient:** Requires `V^2` space, regardless of the number of edges. This is highly inefficient for **sparse graphs** (graphs with few edges).

---

## 3. Adjacency List Representation

An **adjacency list** represents a graph as an array of linked lists. The size of the array is equal to the number of vertices (`V`).

**Structure:**
*   An array `adjList` of size `V` is created.
*   The entry `adjList[i]` contains a pointer to the head of a linked list.
*   This linked list contains all the vertices that are adjacent to vertex `i`.

**Example: Directed Graph**
```
      (A) ---> (B)
       |        |
       |        v
       v       (D) <--- (C)
      (E)
```
Vertices: A=0, B=1, C=2, D=3, E=4

**Adjacency List:**
*   `adjList[0]` -> [ B -> E -> NULL ]
*   `adjList[1]` -> [ D -> NULL ]
*   `adjList[2]` -> [ D -> NULL ]
*   `adjList[3]` -> [ NULL ]
*   `adjList[4]` -> [ NULL ]

[Click here to see a visualization of an Adjacency List](https://www.google.com/search?q=graph+adjacency+list+example&tbm=isch)
> **What to look for:** A diagram showing an array of vertices on the left. From each array index, a linked list of nodes points outwards, with each node representing a neighbor of the source vertex.

**Advantages:**
*   **Space Efficient:** The space required is `O(V + E)`, where `V` is the number of vertices and `E` is the number of edges. This is very efficient for **sparse graphs**.
*   Easy to iterate through all neighbors of a vertex.

**Disadvantages:**
*   **Slower Edge Lookup:** To check if an edge `(i, j)` exists, you must traverse the linked list for vertex `i` and see if `j` is present. This takes `O(degree(i))` time, where `degree(i)` is the number of neighbors of `i`.

---

### Comparison of Representations

| Feature                       | Adjacency Matrix | Adjacency List        |
|-------------------------------|------------------|-----------------------|
| **Space Complexity**          | `O(V^2)`         | `O(V + E)`            |
| **Best for...**               | Dense graphs     | Sparse graphs         |
| **Check Edge (u, v)**         | `O(1)`           | `O(degree(u))`        |
| **Find All Neighbors of u**   | `O(V)`           | `O(degree(u))`        |

---

## Questions

<details>
<summary>1. Differentiate between an adjacency matrix and an adjacency list for graph representation.</summary>

*   **Adjacency Matrix:** A 2D array of size V x V. `matrix[i][j] = 1` indicates an edge between vertex `i` and `j`. It uses `O(V^2)` space and is efficient for checking the existence of an edge (O(1)) but inefficient for sparse graphs.
*   **Adjacency List:** An array of linked lists. The list at index `i` contains all vertices adjacent to vertex `i`. It uses `O(V + E)` space, which is efficient for sparse graphs. However, checking for a specific edge takes longer, O(degree(i)).
</details>

<details>
<summary>2. Consider an undirected, unweighted graph with 5 vertices (0, 1, 2, 3, 4) and the following edges: `(0,1), (0,4), (1,2), (1,3), (1,4), (2,3), (3,4)`. Represent this graph using both an adjacency matrix and an adjacency list.</summary>

**Adjacency Matrix:**
```
    0 1 2 3 4
  0[0 1 0 0 1]
  1[1 0 1 1 1]
  2[0 1 0 1 0]
  3[0 1 1 0 1]
  4[1 1 0 1 0]
```

**Adjacency List:**
*   `List[0]` -> [ 1 -> 4 -> NULL ]
*   `List[1]` -> [ 0 -> 2 -> 3 -> 4 -> NULL ]
*   `List[2]` -> [ 1 -> 3 -> NULL ]
*   `List[3]` -> [ 1 -> 2 -> 4 -> NULL ]
*   `List[4]` -> [ 0 -> 1 -> 3 -> NULL ]
</details>

<details>
<summary>3. For a social network like Facebook, which graph representation (adjacency matrix or adjacency list) would be more suitable and why?</summary>

An **adjacency list** would be far more suitable for a social network.

**Reasoning:** Social networks are classic examples of **sparse graphs**. A user (vertex) is connected to a relatively small number of friends compared to the total number of users on the platform.
*   **Space:** If there are 1 billion users (V = 10^9), an adjacency matrix would require `(10^9)^2 = 10^18` entries, which is an impossibly large amount of memory. An adjacency list would only require `O(V + E)` space, which is manageable because the number of edges `E` (friendships) is much, much smaller than `V^2`.
*   **Functionality:** A common operation is "show me all my friends." This is very efficient with an adjacency list, as it simply requires traversing the linked list for that user. In an adjacency matrix, you would have to scan an entire row of 1 billion columns to find the friends.
</details>
