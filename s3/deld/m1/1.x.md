# MODULE I: Topic 1.X - Module I Cleanup

**Objective:** To fill the remaining gaps in Module I by learning Gray-to-Binary conversion, understanding ASCII, and clarifying the limitations of parity codes.

---

### **1. Gray Code to Binary Conversion**

**Concept:** This is the reverse process of what we learned before. Given a Gray code, we want to find its standard binary equivalent. The method is slightly different but still uses XOR.

**The Rule (Gray to Binary Conversion):**
1.  The Most Significant Bit (MSB) of the Binary number is the same as the MSB of the Gray code.
2.  From left to right, **XOR** the current **Binary bit** (the one you just found) with the **next Gray code bit** to get the next Binary bit.
    *   Formula: `B(i) = B(i+1)  R G(i)` where `B(i+1)` is the binary bit to the left.

*   **[Click here to see a visual diagram of the Gray-to-Binary conversion process.](https://www.google.com/search?tbm=isch&q=gray+to+binary+conversion+steps+diagram)**

*   **Example: Convert Gray Code `1110` to Binary.**
    *   Gray: `G₃ G₂ G₁ G₀` = `1 1 1 0`
    1.  **Find B₃:** The MSB is the same.
        *   `B₃ = G₃ = 1`
    2.  **Find B₂:** XOR the binary bit you just found (`B₃`) with the next Gray bit (`G₂`).
        *   `B₂ = B₃ ⊕ G₂ = 1 ⊕ 1 = 0`
    3.  **Find B₁:** XOR the binary bit you just found (`B₂`) with the next Gray bit (`G₁`).
        *   `B₁ = B₂ ⊕ G₁ = 0 ⊕ 1 = 1`
    4.  **Find B₀:** XOR the binary bit you just found (`B₁`) with the next Gray bit (`G₀`).
        *   `B₀ = B₁ ⊕ G₀ = 1 ⊕ 0 = 1`
    5.  Combine the binary bits: `B₃ B₂ B₁ B₀`
    *   **Answer: `1011` (Binary)**
    *   (You can check this: our previous example converted binary `1011` to gray `1110`, so this is correct).

---

### **2. ASCII (American Standard Code for Information Interchange)**

**Concept:** ASCII is not a number system for calculation; it is a **character encoding standard**. Its purpose is to assign a unique binary number to every letter, digit, punctuation mark, and control character (like 'Enter' or 'Delete') on a standard English keyboard. This allows computers to store, process, and transmit text.

**Key Facts:**
*   **Structure:** Standard ASCII is a **7-bit** code, which allows for `2⁷ = 128` unique characters.
    *   This is enough for all uppercase letters (A-Z), lowercase letters (a-z), digits (0-9), and common symbols (`!`, `@`, `#`, `?`, etc.).
*   **Extended ASCII:** An **8-bit** version that adds another 128 characters for graphical symbols and foreign language letters.
*   **How it works:** When you press the 'A' key, the keyboard sends the 7-bit ASCII code `1000001` (which is 65 in decimal) to the computer.
*   **Important Examples (Good to know conceptually):**
    *   `'A'` = Decimal 65
    *   `'a'` = Decimal 97 (The codes for lowercase are 32 higher than uppercase)
    *   `'0'` = Decimal 48 (The character '0' is different from the number 0)

**Why it's in your syllabus:** It's a fundamental concept in how digital systems handle text, distinguishing it from how they handle numbers meant for arithmetic (like BCD or pure binary).

---

### **3. Parity Code - Limitations**

**Concept:** It's crucial to understand what parity can and *cannot* do.

**What Parity CAN Do:**
*   **Detect a single-bit error.** If one bit flips (from 0 to 1, or 1 to 0), the parity of the received data word will be wrong, and the receiver knows an error occurred.

**What Parity CANNOT Do:**

1.  **It cannot DETECT an even number of errors.**
    *   **Example (Even Parity):**
        *   Original data: `1100`, Parity bit: `0`. Transmitted word: `11000` (two `1`s, which is even).
        *   An error flips **two bits**: The received word is now `10100`.
        *   The receiver counts the `1`s: There are two `1`s. This is an even number.
        *   **Result:** The parity check **PASSES**, and the error goes completely **undetected**.

2.  **It cannot CORRECT any errors.**
    *   If the receiver gets a word like `11010` in an even parity system, it knows there's an error because there are three `1`s (odd).
    *   However, it has **no way of knowing which bit flipped**. The original could have been `01010`, `10010`, `11110`, etc.
    *   Because it can't identify the location of the error, it cannot correct it. The only option is for the receiver to request that the data be sent again.

*   More advanced codes, like **Hamming codes**, are required for error correction.

---
### **YOUR TURN: Module I Cleanup (Practice in Notebook)**

1.  **Gray-to-Binary:** Convert the Gray code `1010` back to its standard binary form.
2.  **ASCII:** Would the ASCII code for the symbol `+` be different from the binary code used to perform the mathematical operation of addition? (Yes/No and a one-sentence explanation).
3.  **Parity Limitations:** An odd parity system is being used. The sender transmits the 4-bit word `1001`.
    *   a) What is the 5-bit word that is actually sent over the wire?
    *   b) During transmission, the first and second bits flip due to noise. What is the 5-bit word the receiver sees?
    *   c) Will the receiver detect the error? Why or why not?

---
This completes all topics for Module I. You are now fully equipped for any question from this module.
