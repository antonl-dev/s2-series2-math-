# Module 3: Digital Logic Components - Answer Key (3.xa.md)

This file provides the detailed answers to the comprehensive questions in `3.x.md`.

---

### Section 1: Comparators and Parity Circuits

1.  **2-Bit Magnitude Comparator Design:**
    *   **Equality (E):** The numbers are equal if both corresponding bits are equal: `A₁=B₁` AND `A₀=B₀`. The logic for bit equality is an XNOR gate.
        `E = (A₁ ⊙ B₁) · (A₀ ⊙ B₀)`
    *   **Greater Than (G):** A is greater than B if A₁ is greater than B₁ (A₁=1, B₁=0), OR if A₁ equals B₁ and A₀ is greater than B₀ (A₀=1, B₀=0).
        `G = (A₁ · B₁') + (A₁ ⊙ B₁) · (A₀ · B₀')`
    *   **Less Than (L):** A is less than B if A₁ is less than B₁ (A₁=0, B₁=1), OR if A₁ equals B₁ and A₀ is less than B₀ (A₀=0, B₀=1).
        `L = (A₁' · B₁) + (A₁ ⊙ B₁) · (A₀' · B₀)`

2.  **Parity Generator vs. Checker:**
    *   A **Parity Generator** is a circuit used at the *sending* end. It takes a block of data, counts the number of 1s, and generates an additional parity bit (either 0 or 1) to make the total number of 1s in the message (data + parity bit) either even or odd, depending on the system.
    *   A **Parity Checker** is a circuit used at the *receiving* end. It takes the received message (data + parity bit), counts the total number of 1s, and outputs an error signal if the parity does not match the system's convention (e.g., if it finds an odd number of 1s in an even parity system).

3.  **4-Bit Even Parity Generator:**
    *   **Boolean Expression:** For even parity, the parity bit P should be 1 if the number of 1s in the data is odd. This is the exact function of cascading XOR gates.
        `P = D₃ ⊕ D₂ ⊕ D₁ ⊕ D₀`
    *   **Logic Circuit:** The circuit consists of three 2-input XOR gates connected in a cascading chain.
        [Click here for the circuit diagram](https://www.google.com/search?tbm=isch&q=4-bit+even+parity+generator+logic+circuit)

4.  **Odd Parity Example:**
    *   The data word is `1011`. It contains three 1s (an odd number).
    *   In an **odd parity** system, the goal is to have a total odd number of 1s. Since the data already has an odd number of 1s, the parity bit must be **0**.
    *   The transmitted 5-bit message is `10110`.
    *   The receiver gets `10111`. The parity checker counts the number of 1s in the received message, which is four (an even number).
    *   Since the system is odd parity, an even number of 1s indicates an error. **Yes, the checker will detect an error.**

5.  **Limitation of Single Parity Bit:**
    The primary limitation is that it can only reliably detect an **odd number of bit errors** (e.g., 1 bit, 3 bits, etc.). If an even number of bits (e.g., 2 bits) are flipped during transmission, the parity of the message remains the same, and the error goes **undetected**.

---

### Section 2: Encoders and Decoders

6.  **Encoder vs. Decoder:**
    *   **Function:** An encoder converts an active input line into a binary code (many-to-few). A decoder converts a binary code into a single active output line (few-to-many).
    *   **Inputs/Outputs:** An encoder has up to 2ⁿ inputs and n outputs. A decoder has n inputs and up to 2ⁿ outputs.
    *   **Implementation:** Simple encoders are typically implemented with OR gates. Decoders are typically implemented with AND gates.

7.  **Priority Encoder Advantage:**
    The main advantage is that it resolves ambiguity when multiple inputs are active simultaneously. It establishes a priority hierarchy and outputs the code for the highest-priority active input.
    *   **Example:** In a simple 4-to-2 encoder, if inputs I₁ and I₂ are both HIGH, the output is `11`, which incorrectly implies input I₃ is active. A priority encoder (with I₂ > I₁) would ignore I₁ and correctly output `10`, the code for I₂.

8.  **Implement F(A,B,C) = Σm(0, 2, 3, 7) with a Decoder:**
    *   Connect A, B, and C to the input lines of a 3-to-8 decoder.
    *   Connect the decoder's output lines Y₀, Y₂, Y₃, and Y₇ to the inputs of a 4-input OR gate.
    *   The output of the OR gate is the function F.
        [Click here for a similar circuit diagram](https://www.google.com/search?tbm=isch&q=implement+F(A,B,C)+=+Σm(0,2,3,7)+with+3-to-8+decoder)

9.  **4-to-16 from two 3-to-8 Decoders:**
    *   Connect the lower 3 input bits (A₂, A₁, A₀) to the inputs of both 3-to-8 decoders in parallel.
    *   The most significant bit, A₃, is used to select which decoder is active.
    *   Connect A₃ directly to the Enable pin of the second decoder (for outputs Y₈-Y₁₅).
    *   Connect A₃ through a NOT gate to the Enable pin of the first decoder (for outputs Y₀-Y₇).
    *   When A₃=0, the first decoder is enabled. When A₃=1, the second is enabled.

10. **Common Anode vs. Common Cathode:**
    *   **Common Cathode:** All LED cathodes are tied to a common ground. To turn a segment ON, its corresponding output pin from the decoder must be **HIGH** (active-high).
    *   **Common Anode:** All LED anodes are tied to a common Vcc. To turn a segment ON, its corresponding output pin from the decoder must be **LOW** (active-low), creating a path for current to flow to ground.

11. **Invalid BCD Input `1100`:**
    *   BCD (Binary Coded Decimal) is a 4-bit code used to represent the decimal digits 0 through 9. The binary combinations for 10 through 15 (`1010` to `1111`) are not used and are considered invalid BCD inputs.
    *   During the K-map design process, these invalid inputs will never occur. Therefore, we can treat their corresponding output values as **"Don't Cares" (X)**. This provides more flexibility in grouping 1s, often leading to a simpler, more minimized logic circuit.

---

### Section 3: Code Converters

12. **Binary-to-Gray Converter:** The circuit consists of the MSB being passed through, and three XOR gates where `Gᵢ = Bᵢ₊₁ ⊕ Bᵢ`.
    [Click here for the circuit diagram](https://www.google.com/search?tbm=isch&q=4-bit+binary+to+gray+code+converter+logic+circuit)

13. **Gray-to-Binary Converter:** The circuit consists of the MSB being passed through, and three XOR gates in a feedback arrangement where `Bᵢ = Bᵢ₊₁ ⊕ Gᵢ`.
    [Click here for the circuit diagram](https://www.google.com/search?tbm=isch&q=4-bit+gray+to+binary+code+converter+logic+circuit)

14. **Binary `1101` to Gray:**
    *   `G₃ = B₃ = 1`
    *   `G₂ = B₃ ⊕ B₂ = 1 ⊕ 1 = 0`
    *   `G₁ = B₂ ⊕ B₁ = 1 ⊕ 0 = 1`
    *   `G₀ = B₁ ⊕ B₀ = 0 ⊕ 1 = 1`
    *   Result: **`1011`**

15. **Gray `1010` to Binary:**
    *   `B₃ = G₃ = 1`
    *   `B₂ = B₃ ⊕ G₂ = 1 ⊕ 0 = 1`
    *   `B₁ = B₂ ⊕ G₁ = 1 ⊕ 1 = 0`
    *   `B₀ = B₁ ⊕ G₀ = 0 ⊕ 0 = 0`
    *   Result: **`1100`**

---

### Section 4: Multiplexers and Demultiplexers

16. **Implement F(A,B,C,D) = Σm(0,2,5,8,10,11,14,15) with 8-to-1 MUX:**
    *   Connect A, B, C to select lines S₂, S₁, S₀. Use D for the data inputs.
    *   **Implementation Table:**
    | A,B,C | D=0 Minterm | D=1 Minterm | F(D=0) | F(D=1) | Input Iᵢ |
    |-------|-------------|-------------|--------|--------|----------|
    | 000   | m₀          | m₁          | 1      | 0      | **D'**   |
    | 001   | m₂          | m₃          | 1      | 0      | **D'**   |
    | 010   | m₄          | m₅          | 0      | 1      | **D**    |
    | 011   | m₆          | m₇          | 0      | 0      | **0**    |
    | 100   | m₈          | m₉          | 1      | 0      | **D'**   |
    | 101   | m₁₀         | m₁₁         | 1      | 1      | **1**    |
    | 110   | m₁₂         | m₁₃         | 0      | 0      | **0**    |
    | 111   | m₁₄         | m₁₅         | 1      | 1      | **1**    |
    *   **Connections:** I₀→D', I₁→D', I₂→D, I₃→0, I₄→D', I₅→1, I₆→0, I₇→1.

17. **Decoder as DEMUX:**
    A 2-to-4 decoder with an enable input is identical to a 1-to-4 DEMUX.
    *   Connect the DEMUX select lines (S₁, S₀) to the decoder's inputs (A₁, A₀).
    *   Connect the DEMUX single data input (D) to the decoder's Enable (E) pin.
    *   The decoder's outputs (Y₃-Y₀) will function as the demultiplexer's outputs.

18. **1-to-4 DEMUX Circuit:**
    The circuit consists of four 3-input AND gates and two inverters. The data input D goes to all four AND gates. The select lines S₁ and S₀ (and their complements) are used to enable only one AND gate at a time.
    [Click here for the circuit diagram](https://www.google.com/search?tbm=isch&q=1-to-4+demux+logic+circuit)

19. **Full Adder using a Decoder/DEMUX:**
    *   Connect the adder inputs A, B, Cin to the decoder's select lines S₂, S₁, S₀.
    *   Tie the decoder's data/enable input to HIGH (logic 1).
    *   **Sum Expression:** `Sum = Σm(1, 2, 4, 7)`. Connect decoder outputs Y₁, Y₂, Y₄, Y₇ to a 4-input OR gate.
    *   **Carry Expression:** `Carry = Σm(3, 5, 6, 7)`. Connect decoder outputs Y₃, Y₅, Y₆, Y₇ to a second 4-input OR gate.

---

### Section 5: ALU Architecture

20. **ALU Block Schematic:**
    The diagram should include two `n`-bit inputs (A, B), an `m`-bit Function Select input, an `n`-bit Result output (Y), and a Status Flags output. Internally, it should show an Arithmetic Unit and a Logic Unit operating in parallel, with their results feeding into a large multiplexer controlled by the Function Select lines.
    [Click here for a reference diagram](https://www.google.com/search?tbm=isch&q=simple+ALU+block+diagram)

21. **ALU Status Flags:**
    Status flags provide information about the result of the most recent ALU operation.
    *   **Zero Flag (Z):** Set to 1 if the result is all zeros; 0 otherwise. Used to check for equality (e.g., after A-B).
    *   **Carry Flag (C):** Set to 1 if an unsigned addition results in a carry-out of the MSB, or if a subtraction requires a borrow.
    *   **Sign Flag (S/N):** A copy of the MSB of the result. In 2's complement, an MSB of 1 indicates a negative number.

22. **Subtraction in an ALU:**
    Subtraction is performed using addition with the 2's complement of the second operand. The operation `A - B` is calculated as `A + (2's complement of B)`. The 2's complement of B is found by inverting all its bits and adding 1 (`B' + 1`). Therefore, the ALU implements subtraction as `A + B' + 1`. This is efficient because it reuses the main adder circuit. The "add 1" part is often accomplished by setting the initial carry-in (C_in) of the adder to 1.
