# Module 2: Comprehensive Questions

This file contains a comprehensive set of questions covering all topics from Module 2 (Sections 2.1 to 2.5).

---

### Part A: Boolean Algebra and Simplification (from 2.1 & 2.2)

1.  State De Morgan's two theorems. Use a truth table to prove `(A + B)' = A' · B'`.

2.  Simplify the following Boolean expression using algebraic laws: `Y = AB + A(B + C) + B(B + C)`.

3.  What makes NAND and NOR gates "universal gates"? Show how to implement a 2-input AND gate using only 2-input NAND gates.

4.  A 4-variable function is given by `F(A,B,C,D) = Σm(0, 2, 5, 7, 8, 10, 13, 15)`.
    a. Write the function in its canonical POS form using Pi (Π) notation.
    b. What are the maxterm expressions for `M₅` and `M₁₀`?

5.  Convert the non-standard expression `F(X,Y,Z) = X'Y + Z` into its canonical SOP form.

---

### Part B: K-Map Simplification (from 2.3)

6.  Simplify the Boolean function `F(A,B,C,D) = Σm(0, 1, 2, 4, 5, 6, 8, 9, 12, 13, 14)` using a Karnaugh map.

7.  A smart traffic control system's main green light (G) logic is described by the function `G(A,B,E,P) = Σm(9, 11, 12, 13, 14, 15) + Σd(8, 10)`, where A=Main road vehicle, B=Side road vehicle, E=Emergency, P=Pedestrian. Find the simplest SOP expression for G using a K-map.

8.  Simplify the following function into its simplest POS form by grouping the zeros on a K-map: `F(X,Y,Z) = Σm(0, 2, 4, 6, 7)`.

---

### Part C: Combinational Logic Circuits (from 2.4 & 2.5)

9.  Draw the logic circuit of a Full Adder using two Half Adders and an OR gate. Label all inputs (A, B, Cin) and outputs (Sum, Cout).

10. What is the primary difference between a Half Subtractor and a Full Subtractor?

11. Explain how a 4-bit parallel adder circuit can be configured to perform subtraction using a single mode control line (M). Draw a block diagram for one bit-slice showing the XOR gate.

12. Define "Carry Generate" (Gᵢ) and "Carry Propagate" (Pᵢ) for a Carry Look-Ahead Adder. Why is this type of adder significantly faster than a ripple-carry adder for a large number of bits?


---

# Module 2: Comprehensive Questions - Answer Key

---

### Part A: Boolean Algebra and Simplification (from 2.1 & 2.2)

**1. De Morgan's Theorems:**
   - Theorem 1: `(A + B)' = A' · B'`
   - Theorem 2: `(A · B)' = A' + B'`
   - **Proof for T1:**
| A | B | A+B | (A+B)' | A' | B' | A'·B' |
|:-:|:-:|:---:|:------:|:--:|:--:|:-----:|
| 0 | 0 |  0  |    **1**   | 1  | 1  |   **1**   |
| 0 | 1 |  1  |    **0**   | 1  | 0  |   **0**   |
| 1 | 0 |  1  |    **0**   | 0  | 1  |   **0**   |
| 1 | 1 |  1  |    **0**   | 0  | 0  |   **0**   |
   Since the columns for `(A+B)'` and `A'·B'` are identical, the theorem is proven.

**2. Simplification:**
   `Y = AB + A(B + C) + B(B + C)`
   `Y = AB + AB + AC + BB + BC` (Distributive Law)
   `Y = AB + AC + B + BC` (Idempotent Law: `AB+AB=AB`, `BB=B`)
   `Y = AB + AC + B(1 + C)` (Factoring B)
   `Y = AB + AC + B` (Annihilation Law: `1+C=1`)
   `Y = B(A + 1) + AC` (Factoring B)
   `Y = B + AC` (Annihilation Law: `A+1=1`)
   **Final Answer: `Y = B + AC`**

**3. Universal Gates:**
   NAND and NOR gates are "universal" because any basic logic function (AND, OR, NOT) can be created using only one type of these gates.
   **AND from NAND:** `A · B = ((A · B)')'`. This is a NAND gate followed by a NAND gate configured as an inverter.

**4. Canonical Forms:**
   Given `F(A,B,C,D) = Σm(0, 2, 5, 7, 8, 10, 13, 15)`. This is a 4-variable function (16 total minterms from 0-15).
   a. **POS Form:** The maxterms are the missing indices from the minterm list.
      `ΠM(1, 3, 4, 6, 9, 11, 12, 14)`
   b. **Maxterm Expressions:**
      - `M₅` (for 0101): `A+B'+C+D'`
      - `M₁₀` (for 1010): `A'+B+C'+D`

**5. Conversion to Canonical SOP:**
   `F(X,Y,Z) = X'Y + Z`
   - Expand `X'Y`: `X'Y(Z+Z') = X'YZ + X'YZ'`
   - Expand `Z`: `Z(X+X') = XZ + X'Z` -> `XZ(Y+Y') + X'Z(Y+Y') = XYZ + XY'Z + X'YZ + X'Y'Z`
   - Combine and remove duplicates: `F = X'YZ + X'YZ' + XYZ + XY'Z + X'Y'Z`
   - **Final Answer:** `Σm(3, 2, 7, 5, 1)` or `Σm(1, 2, 3, 5, 7)`

---

### Part B: K-Map Simplification (from 2.3)

**6. `F(A,B,C,D) = Σm(0,1,2,4,5,6,8,9,12,13,14)`**
   - A large quad group covers `m(0,1,4,5)` -> `A'C'`
   - A large quad group covers `m(4,6,12,14)` -> `CD'`
   - A large quad group covers `m(8,9,12,13)` -> `B'C'` (Error, this should be A=1, B=0, D changes -> `AC'`). Let's re-examine. `m(8,9,12,13)` -> `A=1`, `C'` is constant. Term is `AC'`.
   - The grouping `(m0, m2, m8, m?)` no. Let's regroup.
   - Group 1 (Quad `m0,m4,m12,m8`): `C'D'`
   - Group 2 (Quad `m0,m1,m4,m5`): `A'C'`
   - Group 3 (Quad `m4,m5,m6`... No). Let's restart.
   - **Correct grouping:**
     - A quad covering `m(0,4,8,12)` -> `C'D'`
     - A quad covering `m(0,1,2)`... No.
     - A quad covering `m(4,5,12,13)` -> `C D'` (Error. A changes, B is 0/1, C is constant at 1, D is 0/1. No, C is 0 and D changes. B changes. `B'D'`). Let's be systematic.
     - **Final Correct Grouping:**
       - Quad (`m0, m4, m8, m12`) -> `C'D'`
       - Quad (`m0, m1, m2,` ... No)
       - Quad (`m4, m5, m6,`... No)
       - The most efficient groups are: an Octet `m(0,2,4,6,8,10,12,14)`... no.
       - Let's try again: `F = C' + A'D'`
   - **Final Simplification:** `F = C' + A'D' + B'D'`.

**7. `G(A,B,E,P) = Σm(9, 11, 12, 13, 14, 15) + Σd(8, 10)`**
   - Plotting these on an ABEP map (assuming A is MSB).
   - A quad covers `m(8,9,10,11)` using don't cares -> Term `AB'`.
   - A quad covers `m(12,13,14,15)` -> Term `AE`.
   - **Final Answer:** `G = AB' + AE`

**8. `F(X,Y,Z) = Σm(0, 2, 4, 6, 7)` -> POS Form**
   - The zeros are at `ΠM(1, 3, 5)`.
   - Group the zeros:
     - Pair `M₁(001), M₃(011)` -> `(X+Z')`
     - Pair `M₁(001), M₅(101)` -> `(Y'+Z')`
   - **Final Answer:** `F = (X+Z')(Y'+Z')`

---

### Part C: Combinational Logic Circuits (from 2.4 & 2.5)

**9. Full Adder from Half Adders:**
   - The diagram should show two "HA" blocks. Inputs A and B go into the first HA. Its Sum output goes into the second HA along with Cin. The final Sum comes from the second HA. The Carry outputs from both HA blocks go into an OR gate to produce the final Cout.

**10. Half vs. Full Subtractor:**
   A Half Subtractor subtracts two bits (A, B). A Full Subtractor subtracts three bits (A, B, and a Borrow-in, Bin), making it suitable for cascading in multi-bit subtraction.

**11. 4-Bit Adder/Subtractor:**
   - A mode control line `M` is connected to the second input of an XOR gate for each bit of B, and also to the initial carry-in (C₀) of the adder chain.
   - When `M=0` (Add): `B ⊕ 0 = B`, and `C₀=0`. The circuit calculates `A + B`.
   - When `M=1` (Subtract): `B ⊕ 1 = B'`, and `C₀=1`. The circuit calculates `A + B' + 1`, which is subtraction via 2's complement.

**12. Carry Look-Ahead Adder:**
   - **Carry Generate (Gᵢ) = Aᵢ · Bᵢ**: A carry is generated at stage `i` regardless of the incoming carry.
   - **Carry Propagate (Pᵢ) = Aᵢ ⊕ Bᵢ**: An incoming carry will be propagated to the next stage.
   - It is faster because it calculates all the carry bits simultaneously with dedicated logic, directly from the P and G signals. It does not have to wait for the carry to "ripple" from one stage to the next, which is the main source of delay in a ripple-carry adder.
