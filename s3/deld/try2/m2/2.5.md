# Module 2: Boolean Algebra and Combinational Circuits Design

## 2.5 4-Bit Parallel Adder/Subtractor and Carry Look-Ahead Adders

Single-bit adders are the building blocks for arithmetic operations on multi-bit binary numbers, which are common in all digital systems. This section covers how these blocks are chained together and how their performance can be improved.

### 1. 4-Bit Parallel Adder (Ripple-Carry Adder)

To add two 4-bit binary numbers (e.g., A = A₃A₂A₁A₀ and B = B₃B₂B₁B₀), we can connect Full Adders in series. This configuration is called a **Parallel Adder** or, more specifically, a **Ripple-Carry Adder**.

**Structure:**
*   Four Full Adders are used.
*   The `Carry-out (Cₒᵤₜ)` of each Full Adder is connected to the `Carry-in (Cᵢₙ)` of the next, more significant Full Adder.
*   The initial `Carry-in (C₀)` to the least significant bit (LSB) adder is typically set to `0` for simple addition.

> **Visual Aid:** This circuit is a chain of Full Adder blocks.
>
> [Click here to see a 4-Bit Ripple-Carry Adder Diagram](https://www.google.com/search?tbm=isch&q=4-bit+ripple+carry+adder+block+diagram)
>
> **What to look for:** A block diagram showing four "FA" blocks. The inputs A₀ and B₀ go into the first FA. Its Cₒᵤₜ connects to the Cᵢₙ of the second FA, and so on. The carry "ripples" from right to left.

**Disadvantage: Propagation Delay**
The primary drawback of the ripple-carry adder is its speed. The sum for the most significant bit (S₃) and the final carry-out (C₄) are not valid until the carry has propagated or "rippled" through all the preceding stages. This cumulative delay makes it slow for adders with many bits (e.g., 32 or 64 bits).

### 2. 4-Bit Parallel Adder/Subtractor Circuit

A single circuit can be designed to perform both addition and subtraction. This is achieved by using the 2's complement method for subtraction: **A - B = A + (2's complement of B)**.

Recall that the 2's complement of B is `(1's complement of B) + 1`.
*   The **1's complement** is achieved by inverting each bit of B. An XOR gate is perfect for this: `B ⊕ 1 = B'`.
*   The **+1** is achieved by setting the initial carry-in (C₀) of the adder to `1`.

**Structure:**
A **mode control line (M)** is used to switch between operations:
*   When **M = 0 (Addition):**
    *   Each bit Bᵢ passes through an XOR gate: `Bᵢ ⊕ 0 = Bᵢ` (B is not inverted).
    *   The initial carry-in C₀ is set to `0`.
    *   The circuit performs `A + B + 0`.
*   When **M = 1 (Subtraction):**
    *   Each bit Bᵢ passes through an XOR gate: `Bᵢ ⊕ 1 = Bᵢ'` (B is inverted).
    *   The initial carry-in C₀ is set to `1`.
    *   The circuit performs `A + B' + 1`, which is `A + (2's complement of B)`.

> **Visual Aid:** The circuit is a ripple-carry adder with added XOR gates.
>
> [Click here to see a 4-Bit Adder/Subtractor Circuit Diagram](https://www.google.com/search?tbm=isch&q=4+bit+adder+subtractor+circuit+diagram)
>
> **What to look for:** A diagram of a 4-bit parallel adder, but with an XOR gate placed on each B input before it enters the Full Adder. A single control line `M` should connect to one input of every XOR gate and also to the Cᵢₙ of the first Full Adder.

### 3. Carry Look-Ahead Adder (CLA)

The Carry Look-Ahead Adder is a high-speed adder that solves the propagation delay problem of ripple-carry adders. Instead of waiting for the carry to ripple, it calculates all the carries **in parallel** by using dedicated look-ahead logic.

This is achieved by defining two new signals for each bit position `i`:
*   **Carry Generate (Gᵢ):** A carry is generated at stage `i` if both inputs Aᵢ and Bᵢ are 1. `Gᵢ = Aᵢ · Bᵢ`.
*   **Carry Propagate (Pᵢ):** A carry is propagated through stage `i` if an incoming carry (Cᵢ) will be passed to the next stage. This happens if at least one of the inputs Aᵢ or Bᵢ is 1. `Pᵢ = Aᵢ ⊕ Bᵢ`.

The sum and carry for any stage can be expressed in terms of `P` and `G`:
*   Sum: `Sᵢ = Pᵢ ⊕ Cᵢ`
*   Carry-out: `Cᵢ₊₁ = Gᵢ + Pᵢ·Cᵢ`

#### Look-Ahead Logic
Using these equations, we can express the carry for each stage in terms of the initial carry (C₀) and the P and G signals, which depend only on the original inputs.

*   `C₁ = G₀ + P₀·C₀`
*   `C₂ = G₁ + P₁·C₁ = G₁ + P₁(G₀ + P₀·C₀) = G₁ + P₁G₀ + P₁P₀C₀`
*   `C₃ = G₂ + P₂·C₂ = G₂ + P₂G₁ + P₂P₁G₀ + P₂P₁P₀C₀`
*   `C₄ = G₃ + P₃·C₃ = ...`

Notice that `C₁, C₂, C₃, C₄` do not depend on `C₁, C₂, C₃` respectively. They are calculated directly from the `P` and `G` terms. This means all carries can be computed simultaneously by a dedicated logic block, eliminating the ripple delay.

**Advantage:** The Carry Look-Ahead Adder is significantly faster than a Ripple-Carry Adder, especially for a large number of bits.

---

### Questions

1.  What is the main disadvantage of a Ripple-Carry Adder, and how does it affect the performance of the circuit?
2.  In a 4-bit parallel adder/subtractor circuit, what is the role of the mode control line `M`? Explain its effect on the inputs and the initial carry for both addition and subtraction.
3.  For a Carry Look-Ahead Adder, define the "Carry Generate" (Gᵢ) and "Carry Propagate" (Pᵢ) signals. Write their Boolean expressions.
4.  Write the full Boolean expression for the carry `C₂` in a Carry Look-Ahead Adder in terms of G₀, G₁, P₀, P₁, and the initial carry C₀.
5.  What is the primary advantage of a Carry Look-Ahead Adder compared to a Ripple-Carry Adder?
