# MODULE 4: Flip-Flops, Registers, and Counters: Sequential Logic Design

## 4.1 Introduction to Flip-Flops – SR Flip-Flop

### 1. Sequential vs. Combinational Logic

Digital circuits can be broadly classified into two categories: combinational and sequential. Understanding their fundamental difference is key to grasping the role of flip-flops.

*   **Combinational Logic Circuits:**
    *   The output of a combinational circuit depends **only** on the present values of its inputs.
    *   They have **no memory**. Past inputs do not affect the current output.
    *   Examples include adders, subtractors, decoders, encoders, and multiplexers (covered in Modules 2 & 3).

*   **Sequential Logic Circuits:**
    *   The output of a sequential circuit depends on both the **present inputs** and the **past sequence of inputs**.
    *   This is possible because they have a **memory element**. The memory element stores the previous state of the circuit.
    *   The building blocks of these memory elements are **flip-flops**.
    *   Examples include counters, registers, and state machines.

[Click here for a comparison diagram](https://www.google.com/search?tbm=isch&q=combinational+vs+sequential+logic+circuit)
**What to look for:** A diagram showing a combinational circuit with inputs directly leading to outputs, and a sequential circuit with a feedback loop from the output back to the input through a memory element.

### 2. Introduction to Flip-Flops

A **flip-flop** is a fundamental digital circuit capable of storing a single bit (1 or 0) of information. It is a bistable multivibrator, meaning it has two stable states (HIGH and LOW) and can remain in either state indefinitely until an input trigger causes it to change.

**Key Characteristics:**
*   **Building Blocks:** They are the fundamental building blocks of sequential logic and memory.
*   **Outputs:** A flip-flop typically has two outputs: `Q` (the normal output) and `Q'` (the complemented or inverted output). By definition, `Q'` is always the opposite of `Q`.
*   **State:** The state of the flip-flop is determined by the value of its `Q` output. If `Q=1`, the flip-flop is in the "SET" state. If `Q=0`, it is in the "RESET" state.
*   **Clocking/Triggering:** The inputs to a flip-flop don't change its state immediately. The state change is synchronized with a control signal called a **clock (CLK)**. The transition occurs at a specific point on the clock signal, such as the rising edge (positive edge) or falling edge (negative edge). This process is called **triggering**.

### 3. The SR Flip-Flop (Set-Reset Flip-Flop)

The SR flip-flop is one of the most basic types. Its inputs, `S` (Set) and `R` (Reset), control its state.

*   **S (Set):** When `S` is activated, it forces the `Q` output to `1`.
*   **R (Reset):** When `R` is activated, it forces the `Q` output to `0`.

#### 3.1 Gated SR Latch (Implementation with NAND Gates)

A practical SR flip-flop is constructed using a latch circuit combined with a clock input. The version built with cross-coupled NAND gates is very common.

[Click here for a circuit diagram of an SR Flip-Flop using NAND gates](https://www.google.com/search?tbm=isch&q=SR+flip+flop+using+NAND+gates+circuit)
**What to look for:** A circuit with four NAND gates. Two gates receive the S, R, and CLK inputs, and their outputs feed into two other cross-coupled NAND gates which produce the Q and Q' outputs. Note the feedback loop.

#### 3.2 Operation and Truth Table

The behavior of a clocked SR flip-flop is described by its truth table, which shows the next state (`Qn+1`) based on the current inputs (`S`, `R`) and the present state (`Qn`). The state transition only occurs when the clock signal is active (e.g., on a positive edge, denoted by `↑`).

**Truth Table for a Positive-Edge Triggered SR Flip-Flop:**

| CLK | S | R | Present State (Qn) | Next State (Qn+1) | Action |
| :--: | :-: | :-: | :---: | :---: | :--- |
| ↓ or 0 | X | X | Qn | Qn | **No Change** (Memory) |
| ↑ | 0 | 0 | Qn | Qn | **No Change** (Memory) |
| ↑ | 0 | 1 | X | 0 | **Reset** |
| ↑ | 1 | 0 | X | 1 | **Set** |
| ↑ | 1 | 1 | X | ? | **Invalid / Forbidden** |

*(Where `↑` denotes a rising clock edge, and `X` denotes "don't care")*

**Explanation of States:**
*   **No Clock (CLK=0):** When the clock is inactive, the inputs `S` and `R` have no effect. The flip-flop holds its current value, `Qn+1 = Qn`. This is the memory property.
*   **S=0, R=0 (Hold/Memory):** When a clock pulse arrives while both `S` and `R` are low, the flip-flop's state does not change. It continues to store the previous bit. `Qn+1 = Qn`.
*   **S=0, R=1 (Reset):** If `R` is high and `S` is low when the clock is triggered, the flip-flop is reset. The `Q` output becomes `0`.
*   **S=1, R=0 (Set):** If `S` is high and `R` is low when the clock is triggered, the flip-flop is set. The `Q` output becomes `1`.
*   **S=1, R=1 (Invalid/Forbidden):** This input condition is considered invalid because it tries to set and reset the flip-flop simultaneously. It leads to a race condition where both `Q` and `Q'` outputs might go to the same level (e.g., `1` for NAND implementation), violating the `Q' = NOT Q` rule. This state is unpredictable and should be avoided in circuit design.

#### 3.3 Asynchronous Inputs: Preset and Clear

In addition to the synchronous inputs (S, R, CLK), flip-flops often have **asynchronous** inputs called **Preset (PRE)** and **Clear (CLR)**.

*   These inputs are "overriding" because they affect the flip-flop's state immediately, regardless of the clock signal or the S and R inputs.
*   They are typically **active-low**, meaning they perform their function when the input is `0`.
*   **Preset (PRE):** When activated (PRE=0), it asynchronously SETS the flip-flop (`Q=1`).
*   **Clear (CLR):** When activated (CLR=0), it asynchronously RESETS the flip-flop (`Q=0`).

[Click here for a diagram of an SR Flip-Flop with Preset and Clear](https://www.google.com/search?tbm=isch&q=SR+Flip-Flop+with+Preset+and+Clear)
**What to look for:** The standard SR flip-flop circuit with two additional input lines, PRE and CLR, connected directly to the output NAND gates.

#### 3.4 Excitation Table

While a truth table shows the next state based on inputs, an **excitation table** works in reverse. It shows the required input values (`S` and `R`) needed to transition from a present state (`Qn`) to a desired next state (`Qn+1`). This is crucial for designing sequential circuits.

**SR Flip-Flop Excitation Table:**

| Present State (Qn) | Next State (Qn+1) | S | R |
| :---: | :---: | :-: | :-: |
| 0 | 0 | 0 | X |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | X | 0 |

*(Where `X` denotes "don't care")*

**Explanation:**
*   **0 → 0:** To keep the state at 0, we can either do nothing (S=0, R=0) or actively reset it (S=0, R=1). In either case, S must be 0, and R can be anything. So, `S=0, R=X`.
*   **0 → 1:** The only way to go from 0 to 1 is to SET the flip-flop. So, `S=1, R=0`.
*   **1 → 0:** The only way to go from 1 to 0 is to RESET the flip-flop. So, `S=0, R=1`.
*   **1 → 1:** To keep the state at 1, we can either do nothing (S=0, R=0) or actively set it (S=1, R=0). In either case, R must be 0, and S can be anything. So, `S=X, R=0`.

---

### Questions

1.  What is the fundamental difference between a combinational and a sequential logic circuit? Give an example of each.
2.  What is a flip-flop? Why is it called a "bistable" device?
3.  Draw the logic circuit for an SR flip-flop using only NAND gates.
4.  Explain the purpose of the S, R, and CLK inputs in an SR flip-flop.
5.  Why is the S=1, R=1 input condition considered "invalid" or "forbidden" in a standard SR flip-flop? What happens to the outputs Q and Q' in this state for a NAND gate implementation?
6.  What is the purpose of Preset and Clear inputs? Why are they called "asynchronous" or "overriding" inputs?
7.  Develop the excitation table for an SR flip-flop and explain what it represents.
