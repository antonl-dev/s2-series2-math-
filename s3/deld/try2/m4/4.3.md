## 4.3 T Flip-Flop, JK Master-Slave Flip-Flop, and Flip-Flop Conversions

### 1. The T Flip-Flop (Toggle Flip-Flop)

The T flip-flop is a single-input version of the JK flip-flop. The 'T' stands for **Toggle**. Its primary function is to invert its output state (toggle) every time it receives a clock pulse, provided its `T` input is HIGH.

**Key Features:**
*   **Frequency Division:** Because it toggles its state on each clock pulse (when T=1), the output frequency is exactly half the input clock frequency. This makes it a fundamental building block for frequency dividers and binary counters.
*   **Implementation:** A T flip-flop is most easily implemented by connecting the `J` and `K` inputs of a JK flip-flop together. This common input becomes the `T` input.

[Click here for a diagram of a T Flip-Flop made from a JK Flip-Flop](https://www.google.com/search?tbm=isch&q=T+flip+flop+from+JK+flip+flop)
**What to look for:** A standard JK flip-flop block where the J and K input pins are shorted together to form a single input labeled 'T'.

#### 1.1 Operation and Truth Table

The operation is very simple: if `T=0`, the state holds. If `T=1`, the state toggles.

**Truth Table for a T Flip-Flop:**

| CLK | T | Present State (Qn) | Next State (Qn+1) | Action |
| :--: | :-: | :---: | :---: | :--- |
| ↑ | 0 | Qn | Qn | **No Change** (Hold) |
| ↑ | 1 | Qn | Qn' | **Toggle** |

#### 1.2 T Flip-Flop Excitation Table

The excitation table shows the `T` input required to produce a desired state transition.

| Present State (Qn) | Next State (Qn+1) | T |
| :---: | :---: | :-: |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

**Explanation:**
*   To keep the state the same (0→0 or 1→1), the flip-flop must not toggle, so `T` must be `0`.
*   To change the state (0→1 or 1→0), the flip-flop must toggle, so `T` must be `1`.
*   A concise way to express this is: `T = Qn ⊕ Qn+1` (T is the XOR of the present and next state).

### 2. The JK Master-Slave Flip-Flop

The master-slave configuration was developed to solve a problem in early level-triggered flip-flops called **race-around condition**. This condition occurs in a JK flip-flop when `J=1`, `K=1`, and the clock pulse duration is too long. The output can toggle multiple times within a single clock pulse, leading to an unpredictable final state.

The master-slave configuration prevents this by using two cascaded flip-flops: a **master** and a **slave**.

*   **Master Flip-Flop:** This is typically a JK flip-flop that is activated on the **positive level** (or leading edge) of the clock pulse. It takes the external J and K inputs.
*   **Slave Flip-Flop:** This is typically an SR flip-flop that is activated on the **negative level** (or trailing edge) of the clock pulse, using an inverted clock signal. Its inputs are taken from the outputs of the master flip-flop.

[Click here for a diagram of a JK Master-Slave Flip-Flop](https://www.google.com/search?tbm=isch&q=JK+master+slave+flip+flop+circuit+diagram)
**What to look for:** A block diagram showing two flip-flops connected in series. The clock signal goes directly to the master and through an inverter to the slave. The J and K inputs go to the master, and the master's Q and Q' outputs are connected to the slave's S and R inputs, respectively.

#### 2.1 Operation

1.  **Clock goes HIGH (Leading Edge):**
    *   The master flip-flop is enabled and accepts the J and K inputs. It changes its state accordingly.
    *   The slave flip-flop is disabled because it receives an inverted (LOW) clock signal. Its output remains unchanged.

2.  **Clock goes LOW (Trailing Edge):**
    *   The master flip-flop is disabled, and its inputs are ignored. Its state is now fixed.
    *   The slave flip-flop is enabled (as its clock input goes HIGH). It takes the state from the master's output (`Q_master` -> `S`, `Q'_master` -> `R`) and transfers it to its own output.

This two-stage process ensures that the final output `Q` only changes once per clock cycle, on the falling edge, thus eliminating the race-around condition.

### 3. Flip-Flop Conversions

Any type of flip-flop can be converted into another type by adding combinational logic to its inputs. The process involves using the excitation table of the *destination* flip-flop to determine the required inputs, and then creating a logic circuit that generates these inputs from the source flip-flop's inputs and outputs.

#### **General Conversion Procedure:**
1.  Write the truth table for the *source* flip-flop (the one you are converting *from*) and the *destination* flip-flop (the one you are converting *to*).
2.  Create a **conversion table** that lists the present state (`Qn`), the inputs of the destination flip-flop, the desired next state (`Qn+1`), and the required inputs for the source flip-flop (using its excitation table).
3.  Use K-maps to derive simplified Boolean expressions for the source flip-flop's inputs in terms of the destination flip-flop's inputs and the present state `Qn`.
4.  Draw the final logic circuit.

#### Example: Convert an SR Flip-Flop to a JK Flip-Flop

**Goal:** Create a JK flip-flop using an SR flip-flop and some external logic gates.

1.  **Conversion Table:** We need to find expressions for `S` and `R` in terms of `J`, `K`, and `Qn`.

| J | K | Qn | Qn+1 | **S** | **R** |
|:-:|:-:|:--:|:----:|:---:|:---:|
| 0 | 0 | 0 | 0 | 0 | X |
| 0 | 0 | 1 | 1 | X | 0 |
| 0 | 1 | 0 | 0 | 0 | X |
| 0 | 1 | 1 | 0 | 0 | 1 |
| 1 | 0 | 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 1 | X | 0 |
| 1 | 1 | 0 | 1 | 1 | 0 |
| 1 | 1 | 1 | 0 | 0 | 1 |

2.  **K-Maps for S and R:**

    *   **For S (in terms of J, K, Qn):**
        The K-map simplification yields `S = J · Qn'`.

    *   **For R (in terms of J, K, Qn):**
        The K-map simplification yields `R = K · Qn`.

3.  **Circuit Diagram:**
    *   Take a standard SR flip-flop.
    *   Connect `J` and `Qn'` to an AND gate, and feed the output to the `S` input.
    *   Connect `K` and `Qn` to another AND gate, and feed the output to the `R` input.

[Click here for a diagram of an SR to JK flip-flop conversion](https://www.google.com/search?tbm=isch&q=SR+to+JK+flip+flop+conversion)
**What to look for:** An SR flip-flop with its Q and Q' outputs fed back through AND gates along with the J and K inputs.

#### Example from Question Paper: Realize a T Flip-Flop using an SR Flip-Flop

This is another common conversion.

1.  **Conversion Table:**

| T | Qn | Qn+1 | **S** | **R** |
|:-:|:--:|:----:|:---:|:---:|
| 0 | 0 | 0 | 0 | X |
| 0 | 1 | 1 | X | 0 |
| 1 | 0 | 1 | 1 | 0 |
| 1 | 1 | 0 | 0 | 1 |

2.  **K-Maps:**
    *   `S = T · Qn'`
    *   `R = T · Qn`

3.  **Circuit Diagram:** This circuit is identical to the JK conversion, but with J and K tied together as the single input T.

---

### Questions

1.  What is the primary application of a T flip-flop? How is its output frequency related to its input clock frequency when T=1?
2.  Show how a T flip-flop can be constructed from a JK flip-flop.
3.  What is the "race-around condition" in a JK flip-flop, and under what input conditions does it occur?
4.  Explain the operation of a JK master-slave flip-flop using its two distinct phases (clock HIGH and clock LOW). How does this configuration solve the race-around problem?
5.  Following the standard procedure, derive the logic required to convert a D flip-flop into a T flip-flop. Draw the final circuit.
6.  **From Question Paper:** Convert an SR flip-flop to a JK flip-flop. Show the conversion table, K-maps, and the final logic diagram.
7.  **From Question Paper:** Realize a T flip-flop using an SR flip-flop. Draw the necessary circuit.
