# Module 1: Number Systems and Logic Gate Fundamentals

## 1.2 Digital Codes

In addition to number systems, digital electronics uses various **codes** to represent data. While a number system is a way of representing quantities, a code is a set of rules for representing information (which could be numbers, letters, or symbols).

### 1. Binary Coded Decimal (BCD)

BCD is a way to represent decimal digits (0-9) using a 4-bit binary code. It is a **weighted code**, where the weights are 8, 4, 2, and 1. It differs from pure binary representation.

*   **Conversion (Decimal to BCD):** Each decimal digit is individually converted to its 4-bit binary equivalent.
*   **Invalid Codes:** The 4-bit binary combinations for 10-15 (`1010` through `1111`) are invalid in BCD.

**Example:** Convert `(47)₁₀` to BCD.
```
  Decimal:   4       7
  BCD:     0100    0111
```
So, `(47)₁₀ = (0100 0111)BCD`. Note that this is different from `(47)₁₀ = (101111)₂`.

#### BCD Addition

BCD addition is performed by adding two BCD numbers using the rules of binary addition. However, a correction is required if the result is invalid.

**Rules for BCD Addition:**
1.  Add the two BCD numbers.
2.  If the 4-bit sum is **9 (`1001`) or less** and **no carry is generated**, the sum is a valid BCD number.
3.  If the 4-bit sum is **greater than 9 (`1001`)** OR if a **carry is generated** from the 4-bit group, the result is invalid.
4.  **Correction:** To correct an invalid result, **add 6 (`0110`)** to the 4-bit group. Any carry generated from this addition is passed to the next 4-bit group.

**Example (from notes):** Perform BCD addition for `59 + 68`.
```
      (Carry)     1
        59      0101  1001
      + 68    + 0110  1000
      ----    ------------
      127     1100  0001
              /       \
             /         \
    Invalid (>9)      Valid (<=9)
     Add 6 (`0110`)
            + 0110
            ------
      1  0010  0001
      |    |     |
      |    |     |
Carry 1 -> 2     1

Propagate the carry:
      (Carry) 1
              0001  (From the first group's carry)
            + 0010  (From the result of the second group)
            ------
              0011  -> 3 (This step is incorrect in the note's calculation, the final answer is 127)

Let's do it correctly step-by-step:

      1   <- Carry from previous stage
      0101      1001   (59)
    + 0110      1000   (68)
    --------------------
      1100      0001   <- Invalid sum for the rightmost group

Step 1: Add the rightmost groups:
   1001 (9) + 1000 (8) = 10001 (17).
   Since a carry was generated, the result is invalid. The sum is 0001.

Step 2: Add the next groups, including the carry:
   1 (carry) + 0101 (5) + 0110 (6) = 1100 (12).
   This result is > 9, so it is also invalid.

Step 3: Correct the results by adding 6 where needed.
   The rightmost sum was 17 (>9), so correct the sum part `0001`: `0001 + 0110 = 0111` (7).
   The leftmost sum was 12 (>9), so correct it: `1100 + 0110 = 10010`. The sum is `0010` (2) and a carry of `1` is generated.

   Result:    1      0010      0111
            (1)      (2)       (7)
   Final Answer: (127)₁₀ is (0001 0010 0111)BCD
```

### 2. Excess-3 (XS-3) Code

This is a **non-weighted** code derived from BCD by adding 3 (`0011`) to each BCD code.

**Key Property: Self-Complementing**
The 9's complement of a decimal digit can be obtained by inverting the bits of its corresponding XS-3 code. This simplifies subtraction circuits.

**Example:**
*   Decimal `2` is `0101` in XS-3.
*   9's complement of `2` is `7`.
*   Inverting the bits of `0101` gives `1010`.
*   `1010` is the XS-3 code for `7`.

**Conversion (Decimal to XS-3):**
1. Convert the decimal digit to BCD.
2. Add `0011` to the BCD code.

**Example (from answer key):** Convert `(156.3)₁₀` to XS-3.
```
Decimal:   1      5      6   .   3
   +3:    +3     +3     +3       +3
        ----   ----   ----     ----
           4      8      9   .    6
   
XS-3:   0100   1000   1001 .  0110
```

### 3. Gray Code

Gray code is a **non-weighted** code where successive code words differ by only a single bit. This property is called the **unit-distance property**. It is very useful in electromechanical systems like shaft encoders where it prevents errors that could arise from multiple bits changing at once.

#### a. Binary to Gray Conversion

**Rules:**
1.  The Most Significant Bit (MSB) of the Gray code is the same as the MSB of the binary number.
2.  From left to right, add each adjacent pair of binary bits (XOR operation) to get the next Gray code bit. Discard any carries.

`G(i) = B(i) ⊕ B(i+1)` (where B(i+1) is the bit to the left)

**Example:** Convert `(10110)₂` to Gray code.
```
B₄ B₃ B₂ B₁ B₀
1  0  1  1  0

G₄ = B₄ = 1
G₃ = B₄ ⊕ B₃ = 1 ⊕ 0 = 1
G₂ = B₃ ⊕ B₂ = 0 ⊕ 1 = 1
G₁ = B₂ ⊕ B₁ = 1 ⊕ 1 = 0
G₀ = B₁ ⊕ B₀ = 1 ⊕ 0 = 1

Result: (11101)Gray
```

#### b. Gray to Binary Conversion

**Rules:**
1.  The MSB of the binary number is the same as the MSB of the Gray code.
2.  From left to right, add (XOR) each binary bit generated to the Gray code bit in the next position. Discard any carries.

`B(i) = G(i) ⊕ B(i+1)` (where B(i+1) is the binary bit already found to the left)

**Example (from question paper):** Convert `(10100110101)Gray` to binary.
```
Gray:   1  0  1  0  0  1  1  0  1  0  1
Binary: 1
        1 ⊕ 0 = 1
          1 ⊕ 1 = 0
            0 ⊕ 0 = 0
              0 ⊕ 0 = 0
                0 ⊕ 1 = 1
                  1 ⊕ 1 = 0
                    0 ⊕ 0 = 0
                      0 ⊕ 1 = 1
                        1 ⊕ 0 = 1
                          1 ⊕ 1 = 0
Result: (11000100110)₂
```

### 4. Error Detection Codes - Parity

A **parity bit** is an extra bit added to a binary word to detect errors during data transmission. It can detect an odd number of bit errors (most commonly a single bit error).

*   **Even Parity:** The parity bit is set to `0` or `1` to make the total number of 1s in the word (including the parity bit) **even**.
*   **Odd Parity:** The parity bit is set to `0` or `1` to make the total number of 1s **odd**.

**Example:** For the data `1011010` (which has four 1s):
*   **Even Parity:** The number of 1s is already even (4), so the even parity bit is `0`. Transmitted word: `01011010`.
*   **Odd Parity:** The number of 1s is even (4). To make it odd, the odd parity bit must be `1`. Transmitted word: `11011010`.

### 5. ASCII Code

The American Standard Code for Information Interchange (ASCII) is a 7-bit code used to represent alphanumeric characters (letters, numbers, punctuation) and control characters. Since it's a 7-bit code, it can represent 2⁷ = 128 different characters. Often, an 8th bit (the MSB) is added for parity checking.

**Examples:**
*   `'A'` = `41₁₆` = `1000001₂`
*   `'a'` = `61₁₆` = `1100001₂`
*   `'5'` = `35₁₆` = `0110101₂`

---

### Questions

1.  Find the Binary code and Gray code of the number `3A81₁₆`.
2.  Convert `(156)₁₀` to BCD and Excess-3 codes.
3.  Perform the BCD addition of `25 + 39`. Show the steps, including any necessary corrections.
4.  What is the primary advantage of Gray code over standard binary in mechanical encoders?
5.  What is a self-complementing code? Give an example and explain its main advantage.
6.  The 7-bit ASCII code for the character 'S' is `1010011`. Determine the 8-bit transmitted word if an **even parity** bit is added at the MSB position.
